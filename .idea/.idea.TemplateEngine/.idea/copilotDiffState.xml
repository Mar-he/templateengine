<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Simple Template Engine&#10;&#10;A flexible and extensible template engine for .NET 8.0 that supports JSON data processing, token replacement, unit conversion, and value formatting with a clean modifier system.&#10;&#10;## Features&#10;&#10;- **JSON Data Processing**: Parse JSON arrays into template items with automatic property mapping&#10;- **Token Replacement**: Replace template tokens with actual values using `{{name.property}}` syntax&#10;- **Unit Conversion**: Convert between different units (speed, temperature, weight, distance, fuel consumption)&#10;- **Value Formatting**: Round numeric values to specified decimal places&#10;- **Extensible Modifier System**: Add custom modifiers using a clean Chain of Responsibility pattern&#10;- **Type Safety**: Support for both numeric and string values with automatic type handling&#10;- **Culture-Invariant**: Consistent number formatting regardless of system locale&#10;&#10;## Quick Start&#10;&#10;### Installation&#10;&#10;Clone the repository and build the project:&#10;&#10;```bash&#10;git clone &lt;repository-url&gt;&#10;cd TemplateEngine&#10;dotnet build&#10;```&#10;&#10;### Basic Usage&#10;&#10;```csharp&#10;using TemplateEngine;&#10;&#10;// JSON data with template items&#10;var jsonData = &quot;&quot;&quot;&#10;[{&#10;  &quot;name&quot;: &quot;speed&quot;,&#10;  &quot;numeric_value&quot;: 100,&#10;  &quot;unit&quot;: &quot;km/h&quot;&#10;}, {&#10;  &quot;name&quot;: &quot;description&quot;, &#10;  &quot;string_value&quot;: &quot;high performance vehicle&quot;&#10;}]&#10;&quot;&quot;&quot;;&#10;&#10;// Create template engine&#10;var engine = new SimpleTemplateEngine(jsonData);&#10;&#10;// Process templates&#10;var result = engine.ProcessTemplate(&quot;Speed: {{speed.value}} {{speed.unit}}&quot;);&#10;// Output: &quot;Speed: 100 km/h&quot;&#10;&#10;var description = engine.ProcessTemplate(&quot;Type: {{description.value}}&quot;);&#10;// Output: &quot;Type: high performance vehicle&quot;&#10;```&#10;&#10;## Template Syntax&#10;&#10;### Basic Tokens&#10;&#10;- `{{name.value}}` - Gets the value (numeric_value or string_value)&#10;- `{{name.unit}}` - Gets the unit of measurement&#10;- `{{name.name}}` - Gets the name of the item&#10;&#10;### Modifiers&#10;&#10;Modifiers can be chained using the `:` separator:&#10;&#10;#### Rounding&#10;```csharp&#10;{{speed.value:round(2)}}        // Round to 2 decimal places&#10;{{speed.value:round(0)}}        // Round to whole number&#10;```&#10;&#10;#### Unit Conversion&#10;```csharp&#10;{{speed.value:convert(mph)}}    // Convert km/h to mph&#10;{{temp.value:convert(fahrenheit)}} // Convert celsius to fahrenheit&#10;{{weight.value:convert(lbs)}}   // Convert kg to pounds&#10;```&#10;&#10;#### Chained Modifiers&#10;```csharp&#10;{{speed.value:convert(mph):round(1)}}  // Convert then round&#10;{{temp.value:round(0):convert(fahrenheit)}} // Round then convert&#10;```&#10;&#10;## Supported Unit Conversions&#10;&#10;| Category | From | To |&#10;|----------|------|-----|&#10;| **Speed** | km/h | mph, m/s, knots |&#10;| **Temperature** | celsius | fahrenheit, kelvin |&#10;| **Weight** | kg | lbs, oz |&#10;| **Distance** | m | ft, inches, miles, km |&#10;| **Fuel Consumption** | l/100km | mpg, mpg_uk, km/l |&#10;&#10;## Advanced Features&#10;&#10;### Custom JSON Options&#10;&#10;```csharp&#10;var engine = new SimpleTemplateEngine(jsonData, options =&gt;&#10;{&#10;    options.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;&#10;    options.AllowTrailingCommas = true;&#10;});&#10;```&#10;&#10;### Custom Modifiers&#10;&#10;Create your own modifiers by implementing `IValueModifier`:&#10;&#10;```csharp&#10;public class MultiplyModifier : IValueModifier&#10;{&#10;    public bool CanHandle(string modifierString)&#10;    {&#10;        return modifierString.StartsWith(&quot;multiply(&quot;) &amp;&amp; modifierString.EndsWith(&quot;)&quot;);&#10;    }&#10;&#10;    public void Apply(ModifierContext context, string modifierString)&#10;    {&#10;        var parameter = modifierString[9..^1]; // Extract parameter&#10;        if (double.TryParse(parameter, out var multiplier))&#10;        {&#10;            context.Value *= multiplier;&#10;        }&#10;    }&#10;}&#10;&#10;// Register the custom modifier&#10;engine.RegisterModifier(new MultiplyModifier());&#10;&#10;// Use it in templates&#10;var result = engine.ProcessTemplate(&quot;{{value.name:multiply(2):round(1)}}&quot;);&#10;```&#10;&#10;## JSON Data Format&#10;&#10;The engine expects JSON arrays with the following structure:&#10;&#10;```json&#10;[{&#10;  &quot;name&quot;: &quot;item_name&quot;,&#10;  &quot;numeric_value&quot;: 123.45,  // Optional: for numeric values&#10;  &quot;string_value&quot;: &quot;text&quot;,   // Optional: for string values  &#10;  &quot;unit&quot;: &quot;kg&quot;             // Optional: unit of measurement&#10;}]&#10;```&#10;&#10;**Important**: Only one of `numeric_value` or `string_value` should be present per item. The `value` property will return `string_value` if present, otherwise `numeric_value`.&#10;&#10;## Architecture&#10;&#10;The template engine follows clean code principles and design patterns:&#10;&#10;- **Strategy Pattern**: Each modifier is a separate strategy&#10;- **Chain of Responsibility**: Modifiers are processed in sequence&#10;- **Open/Closed Principle**: Extensible for new modifiers without changing existing code&#10;- **Single Responsibility**: Each class has a clear, focused purpose&#10;&#10;### Project Structure&#10;&#10;```&#10;TemplateEngine/&#10;├── SimpleTemplateEngine.cs     # Main template engine&#10;├── TemplateItem.cs            # Data model for template items&#10;├── UnitConverter.cs           # Unit conversion logic&#10;├── Modifiers/&#10;│   ├── IValueModifier.cs      # Modifier interface&#10;│   ├── ModifierProcessor.cs   # Modifier coordination&#10;│   ├── RoundModifier.cs       # Rounding functionality&#10;│   └── ConvertModifier.cs     # Unit conversion functionality&#10;└── TemplateEngineTests.cs     # Comprehensive test suite&#10;```&#10;&#10;## Examples&#10;&#10;### Complex Template Processing&#10;&#10;```csharp&#10;var jsonData = &quot;&quot;&quot;&#10;[{&#10;  &quot;name&quot;: &quot;car_speed&quot;,&#10;  &quot;numeric_value&quot;: 120.5,&#10;  &quot;unit&quot;: &quot;km/h&quot;&#10;}, {&#10;  &quot;name&quot;: &quot;fuel_consumption&quot;,&#10;  &quot;numeric_value&quot;: 7.2,&#10;  &quot;unit&quot;: &quot;l/100km&quot;&#10;}, {&#10;  &quot;name&quot;: &quot;temperature&quot;,&#10;  &quot;numeric_value&quot;: 22.5,&#10;  &quot;unit&quot;: &quot;celsius&quot;&#10;}]&#10;&quot;&quot;&quot;;&#10;&#10;var engine = new SimpleTemplateEngine(jsonData);&#10;&#10;var template = &quot;&quot;&quot;&#10;Vehicle Stats:&#10;- Speed: {{car_speed.value:convert(mph):round(1)}} mph&#10;- Consumption: {{fuel_consumption.value:convert(mpg):round(1)}} mpg  &#10;- Temperature: {{temperature.value:convert(fahrenheit):round(0)}}°F&#10;&quot;&quot;&quot;;&#10;&#10;var result = engine.ProcessTemplate(template);&#10;```&#10;&#10;Output:&#10;```&#10;Vehicle Stats:&#10;- Speed: 74.9 mph&#10;- Consumption: 32.7 mpg&#10;- Temperature: 72°F&#10;```&#10;&#10;### Error Handling&#10;&#10;The engine gracefully handles errors:&#10;&#10;- **Missing items**: Unknown tokens remain unchanged in output&#10;- **Invalid conversions**: Returns original value if conversion not supported&#10;- **String values with numeric modifiers**: Ignores modifiers, returns string as-is&#10;- **Malformed JSON**: Returns empty item list&#10;&#10;## Testing&#10;&#10;Run the comprehensive test suite:&#10;&#10;```bash&#10;dotnet test&#10;```&#10;&#10;The project includes 34+ tests covering:&#10;- Basic token replacement&#10;- All unit conversions&#10;- Modifier chaining&#10;- Error conditions&#10;- Custom modifiers&#10;- JSON parsing options&#10;&#10;## Requirements&#10;&#10;- .NET 8.0 or later&#10;- System.Text.Json (included in .NET 8.0)&#10;&#10;## Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch&#10;3. Add tests for new functionality&#10;4. Ensure all tests pass&#10;5. Submit a pull request&#10;&#10;## License&#10;&#10;This project is open source. See LICENSE file for details.&#10;" />
              <option name="updatedContent" value="# Simple Template Engine&#10;&#10;A flexible and extensible template engine for .NET 8.0 that supports JSON data processing, token replacement, unit conversion, and value formatting with a clean modifier system.&#10;&#10;## Features&#10;&#10;- **JSON Data Processing**: Parse JSON arrays into template items with automatic property mapping&#10;- **Token Replacement**: Replace template tokens with actual values using `{{name.property}}` syntax&#10;- **Unit Conversion**: Convert between different units (speed, temperature, weight, distance, fuel consumption)&#10;- **Value Formatting**: Round numeric values to specified decimal places&#10;- **Extensible Modifier System**: Add custom modifiers using a clean Chain of Responsibility pattern&#10;- **Type Safety**: Support for both numeric and string values with automatic type handling&#10;- **Culture-Invariant**: Consistent number formatting regardless of system locale&#10;&#10;## Quick Start&#10;&#10;### Installation&#10;&#10;Clone the repository and build the project:&#10;&#10;```bash&#10;git clone &lt;repository-url&gt;&#10;cd TemplateEngine&#10;dotnet build&#10;```&#10;&#10;### Running Tests&#10;&#10;The project includes a comprehensive test suite with 40+ tests:&#10;&#10;```bash&#10;dotnet test&#10;```&#10;&#10;### Basic Usage&#10;&#10;```csharp&#10;using TemplateEngine;&#10;&#10;// JSON data with template items&#10;var jsonData = &quot;&quot;&quot;&#10;[{&#10;  &quot;name&quot;: &quot;speed&quot;,&#10;  &quot;numeric_value&quot;: 100,&#10;  &quot;unit&quot;: &quot;km/h&quot;&#10;}, {&#10;  &quot;name&quot;: &quot;description&quot;, &#10;  &quot;string_value&quot;: &quot;high performance vehicle&quot;&#10;}]&#10;&quot;&quot;&quot;;&#10;&#10;// Create template engine&#10;var engine = new SimpleTemplateEngine(jsonData);&#10;&#10;// Process templates&#10;var result = engine.ProcessTemplate(&quot;Speed: {{speed.value}} {{speed.unit}}&quot;);&#10;// Output: &quot;Speed: 100 km/h&quot;&#10;&#10;var description = engine.ProcessTemplate(&quot;Type: {{description.value}}&quot;);&#10;// Output: &quot;Type: high performance vehicle&quot;&#10;```&#10;&#10;## Template Syntax&#10;&#10;### Basic Tokens&#10;&#10;- `{{name.value}}` - Gets the value (numeric_value or string_value)&#10;- `{{name.unit}}` - Gets the unit of measurement&#10;- `{{name.name}}` - Gets the name of the item&#10;&#10;### Modifiers&#10;&#10;Modifiers can be chained using the `:` separator:&#10;&#10;#### Rounding&#10;```csharp&#10;{{speed.value:round(2)}}        // Round to 2 decimal places&#10;{{speed.value:round(0)}}        // Round to whole number&#10;```&#10;&#10;#### Unit Conversion&#10;```csharp&#10;{{speed.value:convert(mph)}}    // Convert km/h to mph&#10;{{temp.value:convert(fahrenheit)}} // Convert celsius to fahrenheit&#10;{{weight.value:convert(lbs)}}   // Convert kg to pounds&#10;```&#10;&#10;#### Chained Modifiers&#10;```csharp&#10;{{speed.value:convert(mph):round(1)}}  // Convert then round&#10;{{temp.value:round(0):convert(fahrenheit)}} // Round then convert&#10;```&#10;&#10;## Supported Unit Conversions&#10;&#10;| Category | From | To |&#10;|----------|------|-----|&#10;| **Speed** | km/h | mph, m/s, knots |&#10;| **Temperature** | celsius | fahrenheit, kelvin |&#10;| **Weight** | kg | lbs, oz |&#10;| **Distance** | m | ft, inches, miles, km |&#10;| **Fuel Consumption** | l/100km | mpg, mpg_uk, km/l |&#10;&#10;## Advanced Features&#10;&#10;### Custom JSON Options&#10;&#10;```csharp&#10;var engine = new SimpleTemplateEngine(jsonData, options =&gt;&#10;{&#10;    options.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;&#10;    options.AllowTrailingCommas = true;&#10;});&#10;```&#10;&#10;### Custom Modifiers&#10;&#10;Create your own modifiers by implementing `IValueModifier`:&#10;&#10;```csharp&#10;public class MultiplyModifier : IValueModifier&#10;{&#10;    public bool CanHandle(string modifierString)&#10;    {&#10;        return modifierString.StartsWith(&quot;multiply(&quot;) &amp;&amp; modifierString.EndsWith(&quot;)&quot;);&#10;    }&#10;&#10;    public void Apply(ModifierContext context, string modifierString)&#10;    {&#10;        var parameter = modifierString[9..^1]; // Extract parameter&#10;        if (double.TryParse(parameter, out var multiplier))&#10;        {&#10;            context.Value *= multiplier;&#10;        }&#10;    }&#10;}&#10;&#10;// Register the custom modifier&#10;engine.RegisterModifier(new MultiplyModifier());&#10;&#10;// Use it in templates&#10;var result = engine.ProcessTemplate(&quot;{{value.name:multiply(2):round(1)}}&quot;);&#10;```&#10;&#10;## JSON Data Format&#10;&#10;The engine expects JSON arrays with the following structure:&#10;&#10;```json&#10;[{&#10;  &quot;name&quot;: &quot;item_name&quot;,&#10;  &quot;numeric_value&quot;: 123.45,  // Optional: for numeric values&#10;  &quot;string_value&quot;: &quot;text&quot;,   // Optional: for string values  &#10;  &quot;unit&quot;: &quot;kg&quot;             // Optional: unit of measurement&#10;}]&#10;```&#10;&#10;**Important**: Only one of `numeric_value` or `string_value` should be present per item. The `value` property will return `string_value` if present, otherwise `numeric_value`.&#10;&#10;## Architecture&#10;&#10;The template engine follows clean code principles and design patterns:&#10;&#10;- **Strategy Pattern**: Each modifier is a separate strategy&#10;- **Chain of Responsibility**: Modifiers are processed in sequence&#10;- **Open/Closed Principle**: Extensible for new modifiers without changing existing code&#10;- **Single Responsibility**: Each class has a clear, focused purpose&#10;&#10;### Project Structure&#10;&#10;```&#10;TemplateEngine/&#10;├── TemplateEngine/&#10;│   ├── SimpleTemplateEngine.cs     # Main template engine&#10;│   ├── TemplateItem.cs            # Data model for template items&#10;│   ├── UnitConverter.cs           # Unit conversion logic&#10;│   └── Modifiers/&#10;│       ├── IValueModifier.cs      # Modifier interface&#10;│       ├── ModifierProcessor.cs   # Modifier coordination&#10;│       ├── RoundModifier.cs       # Rounding functionality&#10;│       ��── ConvertModifier.cs     # Unit conversion functionality&#10;└── TemplateEngine.Tests/&#10;    ├── SimpleTemplateEngineTests.cs  # Core template engine tests&#10;    ├── TemplateItemTests.cs          # TemplateItem model tests&#10;    ├── ModifierTests.cs              # Modifier system tests&#10;    └── UnitConverterTests.cs         # Unit conversion tests&#10;```&#10;&#10;## Examples&#10;&#10;### Complex Template Processing&#10;&#10;```csharp&#10;var jsonData = &quot;&quot;&quot;&#10;[{&#10;  &quot;name&quot;: &quot;car_speed&quot;,&#10;  &quot;numeric_value&quot;: 120.5,&#10;  &quot;unit&quot;: &quot;km/h&quot;&#10;}, {&#10;  &quot;name&quot;: &quot;fuel_consumption&quot;,&#10;  &quot;numeric_value&quot;: 7.2,&#10;  &quot;unit&quot;: &quot;l/100km&quot;&#10;}, {&#10;  &quot;name&quot;: &quot;temperature&quot;,&#10;  &quot;numeric_value&quot;: 22.5,&#10;  &quot;unit&quot;: &quot;celsius&quot;&#10;}]&#10;&quot;&quot;&quot;;&#10;&#10;var engine = new SimpleTemplateEngine(jsonData);&#10;&#10;var template = &quot;&quot;&quot;&#10;Vehicle Stats:&#10;- Speed: {{car_speed.value:convert(mph):round(1)}} mph&#10;- Consumption: {{fuel_consumption.value:convert(mpg):round(1)}} mpg  &#10;- Temperature: {{temperature.value:convert(fahrenheit):round(0)}}°F&#10;&quot;&quot;&quot;;&#10;&#10;var result = engine.ProcessTemplate(template);&#10;```&#10;&#10;Output:&#10;```&#10;Vehicle Stats:&#10;- Speed: 74.9 mph&#10;- Consumption: 32.7 mpg&#10;- Temperature: 72°F&#10;```&#10;&#10;### Error Handling&#10;&#10;The engine gracefully handles errors:&#10;&#10;- **Missing items**: Unknown tokens remain unchanged in output&#10;- **Invalid conversions**: Returns original value if conversion not supported&#10;- **String values with numeric modifiers**: Ignores modifiers, returns string as-is&#10;- **Malformed JSON**: Returns empty item list&#10;&#10;## Testing&#10;&#10;Run the comprehensive test suite:&#10;&#10;```bash&#10;dotnet test&#10;```&#10;&#10;The project includes 34+ tests covering:&#10;- Basic token replacement&#10;- All unit conversions&#10;- Modifier chaining&#10;- Error conditions&#10;- Custom modifiers&#10;- JSON parsing options&#10;&#10;## Requirements&#10;&#10;- .NET 8.0 or later&#10;- System.Text.Json (included in .NET 8.0)&#10;&#10;## Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch&#10;3. Add tests for new functionality&#10;4. Ensure all tests pass&#10;5. Submit a pull request&#10;&#10;## License&#10;&#10;This project is open source. See LICENSE file for details." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine.Tests/ModifierTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine.Tests/ModifierTests.cs" />
              <option name="updatedContent" value="using Xunit;&#10;using System.Globalization;&#10;using TemplateEngine.Modifiers;&#10;&#10;namespace TemplateEngine.Tests;&#10;&#10;public class ModifierTests&#10;{&#10;    [Fact]&#10;    public void ProcessTemplate_WithRounding_RoundsCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 123.456789, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;123.46&quot;, engine.ProcessTemplate(&quot;{{speed.value:round(2)}}&quot;));&#10;        Assert.Equal(&quot;123&quot;, engine.ProcessTemplate(&quot;{{speed.value:round(0)}}&quot;));&#10;        Assert.Equal(&quot;123.4568&quot;, engine.ProcessTemplate(&quot;{{speed.value:round(4)}}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithUnitConversion_ConvertsCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100, Unit = &quot;km/h&quot; },&#10;            new() { Name = &quot;consumption&quot;, NumericValue = 8.5, Unit = &quot;l/100km&quot; },&#10;            new() { Name = &quot;temp&quot;, NumericValue = 25, Unit = &quot;celsius&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert - Use rounded values to avoid floating point precision issues&#10;        Assert.Equal(&quot;62.1371&quot;, engine.ProcessTemplate(&quot;{{speed.value:convert(mph):round(4)}}&quot;));&#10;        Assert.Equal(&quot;27.7&quot;, engine.ProcessTemplate(&quot;{{consumption.value:convert(mpg):round(1)}}&quot;));&#10;        Assert.Equal(&quot;77&quot;, engine.ProcessTemplate(&quot;{{temp.value:convert(fahrenheit):round(0)}}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithConvertAndRound_AppliesInOrder()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;62.1&quot;, engine.ProcessTemplate(&quot;{{speed.value:convert(mph):round(1)}}&quot;));&#10;        Assert.Equal(&quot;62&quot;, engine.ProcessTemplate(&quot;{{speed.value:convert(mph):round(0)}}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithRoundAndConvert_AppliesInOrder()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100.789, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        // First round to 101, then convert to mph&#10;        Assert.Equal(&quot;62.8&quot;, engine.ProcessTemplate(&quot;{{speed.value:round(0):convert(mph):round(1)}}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithInvalidConversion_ReturnsOriginalValue()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;weight&quot;, NumericValue = 100, Unit = &quot;kg&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act - Try to convert kg to mph (invalid conversion)&#10;        var result = engine.ProcessTemplate(&quot;{{weight.value:convert(mph)}}&quot;);&#10;        &#10;        // Assert - Should return original value since conversion is not possible&#10;        Assert.Equal(&quot;100&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithStringValue_IgnoresModifiers()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;type&quot;, StringValue = &quot;electric power&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(&quot;{{type.value:round(2)}}&quot;);&#10;        &#10;        // Assert - String values should ignore numeric modifiers&#10;        Assert.Equal(&quot;electric power&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_ComplexTemplate_HandlesMultipleConversions()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;: &quot;car_speed&quot;,&#10;          &quot;numeric_value&quot;: 120.5,&#10;          &quot;unit&quot;: &quot;km/h&quot;&#10;        }, {&#10;          &quot;name&quot;: &quot;fuel_consumption&quot;,&#10;          &quot;numeric_value&quot;: 7.2,&#10;          &quot;unit&quot;: &quot;l/100km&quot;&#10;        }, {&#10;          &quot;name&quot;: &quot;temperature&quot;,&#10;          &quot;numeric_value&quot;: 22.5,&#10;          &quot;unit&quot;: &quot;celsius&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Speed: {{car_speed.value:convert(mph):round(1)}} mph, &quot; +&#10;                      &quot;Consumption: {{fuel_consumption.value:convert(mpg):round(1)}} mpg, &quot; +&#10;                      &quot;Temp: {{temperature.value:convert(fahrenheit):round(0)}}°F&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert - 22.5°C = 72.5°F, rounded to 72°F (banker's rounding)&#10;        Assert.Equal(&quot;Speed: 74.9 mph, Consumption: 32.7 mpg, Temp: 72°F&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void RegisterModifier_CustomModifier_WorksCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;test&quot;, NumericValue = 10, Unit = &quot;units&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Create a custom modifier that multiplies by 2&#10;        var customModifier = new TestMultiplyModifier();&#10;        engine.RegisterModifier(customModifier);&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(&quot;{{test.value:multiply(2)}}&quot;);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;20&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ModifierProcessor_ChainedCustomModifiers_WorksCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;test&quot;, NumericValue = 5.555, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Register custom modifier&#10;        engine.RegisterModifier(new TestMultiplyModifier());&#10;        &#10;        // Act - Test chaining custom modifier with existing ones&#10;        var result = engine.ProcessTemplate(&quot;{{test.value:multiply(2):convert(mph):round(1)}}&quot;);&#10;        &#10;        // Assert - 5.555 * 2 = 11.11 km/h -&gt; ~6.9 mph -&gt; 6.9&#10;        Assert.Equal(&quot;6.9&quot;, result);&#10;    }&#10;}&#10;&#10;// Test helper class for custom modifier&#10;public class TestMultiplyModifier : IValueModifier&#10;{&#10;    public bool CanHandle(string modifierString)&#10;    {&#10;        return modifierString.StartsWith(&quot;multiply(&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; &#10;               modifierString.EndsWith(&quot;)&quot;);&#10;    }&#10;&#10;    public void Apply(ModifierContext context, string modifierString)&#10;    {&#10;        var parameter = modifierString[9..^1]; // Extract between &quot;multiply(&quot; and &quot;)&quot;&#10;        if (double.TryParse(parameter, NumberStyles.Float, CultureInfo.InvariantCulture, out var multiplier))&#10;        {&#10;            context.Value *= multiplier;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine.Tests/SimpleTemplateEngineTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine.Tests/SimpleTemplateEngineTests.cs" />
              <option name="updatedContent" value="using Xunit;&#10;using System.Text.Json;&#10;&#10;namespace TemplateEngine.Tests;&#10;&#10;public class SimpleTemplateEngineTests&#10;{&#10;    [Fact]&#10;    public void ProcessTemplate_WithNumericValue_ReplacesTokenCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;The weight is {{foo.value}} {{foo.unit}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;The weight is 2 kg&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithStringValue_ReplacesTokenCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;string_value&quot;: &quot;electric power&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;The type is {{foo.value}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;The type is electric power&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithMultipleItems_ReplacesAllTokens()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;weight&quot;,&#10;          &quot;numeric_value&quot;: 2.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }, {&#10;          &quot;name&quot;:&quot;type&quot;,&#10;          &quot;string_value&quot;: &quot;electric power&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Item: {{type.value}}, Weight: {{weight.value}} {{weight.unit}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Item: electric power, Weight: 2.5 kg&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNameToken_ReplacesCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;foo&quot;, NumericValue = 42, Unit = &quot;units&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        var template = &quot;Name: {{foo.name}}, Value: {{foo.value}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Name: foo, Value: 42&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNonExistentItem_LeavesTokenUnchanged()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Value: {{bar.value}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Value: {{bar.value}}&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNonExistentProperty_LeavesTokenUnchanged()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Value: {{foo.unknown}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Value: {{foo.unknown}}&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithMissingUnit_ReturnsEmptyString()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;string_value&quot;: &quot;test&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Unit: '{{foo.unit}}'&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Unit: ''&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ParseJsonData_CaseInsensitive_ParsesCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;NAME&quot;:&quot;FOO&quot;,&#10;          &quot;NUMERIC_VALUE&quot;: 123,&#10;          &quot;UNIT&quot;: &quot;KG&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;{{FOO.value}} {{FOO.unit}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;123 KG&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithCustomJsonOptions_AppliesCustomConfiguration()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;myCustomName&quot;:&quot;test_item&quot;,&#10;          &quot;myCustomNumericValue&quot;: 42.5,&#10;          &quot;myCustomUnit&quot;: &quot;customUnit&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act&#10;        var engine = new SimpleTemplateEngine(jsonData, options =&gt;&#10;        {&#10;            // Override the default naming policy to use camel case&#10;            options.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;&#10;        });&#10;        &#10;        // Since we changed to camel case and the JSON properties don't match our C# properties,&#10;        // this should result in a TemplateItem with default values&#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should have one item but with default/null values since property mapping failed&#10;        Assert.Single(items);&#10;        Assert.True(string.IsNullOrEmpty(items[0].Name));&#10;        Assert.Null(items[0].NumericValue);&#10;        Assert.Null(items[0].StringValue);&#10;        Assert.Null(items[0].Unit);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithoutCustomJsonOptions_UsesDefaults()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;test_item&quot;,&#10;          &quot;numeric_value&quot;: 42.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act - No custom options provided&#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should parse correctly with default options&#10;        Assert.Single(items);&#10;        Assert.Equal(&quot;test_item&quot;, items[0].Name);&#10;        Assert.Equal(42.5, items[0].NumericValue);&#10;        Assert.Equal(&quot;kg&quot;, items[0].Unit);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithCustomJsonOptions_PreservesDefaults()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;test_item&quot;,&#10;          &quot;numeric_value&quot;: 42.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act - Custom options that don't interfere with existing functionality&#10;        var engine = new SimpleTemplateEngine(jsonData, options =&gt;&#10;        {&#10;            // Add a custom option while preserving defaults&#10;            options.AllowTrailingCommas = true;&#10;            options.ReadCommentHandling = JsonCommentHandling.Skip;&#10;        });&#10;        &#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should still work with default case insensitive and snake_case settings&#10;        Assert.Single(items);&#10;        Assert.Equal(&quot;test_item&quot;, items[0].Name);&#10;        Assert.Equal(42.5, items[0].NumericValue);&#10;        Assert.Equal(&quot;kg&quot;, items[0].Unit);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine.Tests/TemplateItemTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine.Tests/TemplateItemTests.cs" />
              <option name="updatedContent" value="using Xunit;&#10;&#10;namespace TemplateEngine.Tests;&#10;&#10;public class TemplateItemTests&#10;{&#10;    [Fact]&#10;    public void TemplateItem_Value_ReturnsStringValueWhenBothExist()&#10;    {&#10;        // Arrange&#10;        var item = new TemplateItem&#10;        {&#10;            Name = &quot;test&quot;,&#10;            StringValue = &quot;string&quot;,&#10;            NumericValue = 42&#10;        };&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;string&quot;, item.Value);&#10;    }&#10;&#10;    [Fact]&#10;    public void TemplateItem_Value_ReturnsNumericValueWhenStringIsNull()&#10;    {&#10;        // Arrange&#10;        var item = new TemplateItem&#10;        {&#10;            Name = &quot;test&quot;,&#10;            StringValue = null,&#10;            NumericValue = 42&#10;        };&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(42.0, item.Value);&#10;    }&#10;&#10;    [Fact]&#10;    public void TemplateItem_Value_ReturnsNullWhenBothAreNull()&#10;    {&#10;        // Arrange&#10;        var item = new TemplateItem&#10;        {&#10;            Name = &quot;test&quot;,&#10;            StringValue = null,&#10;            NumericValue = null&#10;        };&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Null(item.Value);&#10;    }&#10;&#10;    [Fact]&#10;    public void TemplateItem_DefaultValues_AreCorrect()&#10;    {&#10;        // Arrange &amp; Act&#10;        var item = new TemplateItem();&#10;        &#10;        // Assert&#10;        Assert.Equal(string.Empty, item.Name);&#10;        Assert.Null(item.NumericValue);&#10;        Assert.Null(item.StringValue);&#10;        Assert.Null(item.Unit);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine.Tests/UnitConverterTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine.Tests/UnitConverterTests.cs" />
              <option name="originalContent" value="using Xunit;&#10;&#10;namespace TemplateEngine.Tests;&#10;&#10;public class UnitConverterTests&#10;{&#10;    [Theory]&#10;    [InlineData(&quot;km/h&quot;, &quot;mph&quot;, 100, 62.1371)]&#10;    [InlineData(&quot;km/h&quot;, &quot;m/s&quot;, 36, 10)]&#10;    [InlineData(&quot;l/100km&quot;, &quot;mpg&quot;, 8, 29.401822875)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 0, 32)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 100, 212)]&#10;    [InlineData(&quot;kg&quot;, &quot;lbs&quot;, 1, 2.20462)]&#10;    [InlineData(&quot;m&quot;, &quot;ft&quot;, 1, 3.28084)]&#10;    public void Convert_ValidConversions_ReturnsExpectedResult(string fromUnit, string toUnit, double input, double expected)&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(input, fromUnit, toUnit);&#10;        &#10;        // Assert&#10;        Assert.Equal(expected, result, 5); // 5 decimal places precision&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_InvalidConversion_ReturnsOriginalValue()&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(100, &quot;kg&quot;, &quot;mph&quot;);&#10;        &#10;        // Assert&#10;        Assert.Equal(100, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_ValidConversion_ReturnsTrue()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.True(UnitConverter.CanConvert(&quot;km/h&quot;, &quot;mph&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;l/100km&quot;, &quot;mpg&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;celsius&quot;, &quot;fahrenheit&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_InvalidConversion_ReturnsFalse()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.False(UnitConverter.CanConvert(&quot;kg&quot;, &quot;mph&quot;));&#10;        Assert.False(UnitConverter.CanConvert(&quot;nonexistent&quot;, &quot;mph&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_ValidUnit_ReturnsConversions()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;km/h&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Contains(&quot;mph&quot;, conversions);&#10;        Assert.Contains(&quot;m/s&quot;, conversions);&#10;        Assert.Contains(&quot;knots&quot;, conversions);&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_InvalidUnit_ReturnsEmpty()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;nonexistent&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Empty(conversions);&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_CaseInsensitive_WorksCorrectly()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.Equal(62.1371, UnitConverter.Convert(100, &quot;KM/H&quot;, &quot;MPH&quot;), 4);&#10;        Assert.Equal(62.1371, UnitConverter.Convert(100, &quot;km/h&quot;, &quot;MPH&quot;), 4);&#10;        Assert.Equal(62.1371, UnitConverter.Convert(100, &quot;KM/H&quot;, &quot;mph&quot;), 4);&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_AllSpeedConversions_WorkCorrectly()&#10;    {&#10;        // Test all speed conversions from km/h&#10;        Assert.Equal(27.778, UnitConverter.Convert(100, &quot;km/h&quot;, &quot;m/s&quot;), 3);&#10;        Assert.Equal(53.996, UnitConverter.Convert(100, &quot;km/h&quot;, &quot;knots&quot;), 3);&#10;        &#10;        // Test reverse conversions&#10;        Assert.Equal(100, UnitConverter.Convert(62.1371, &quot;mph&quot;, &quot;km/h&quot;), 0);&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_AllTemperatureConversions_WorkCorrectly()&#10;    {&#10;        // Test celsius conversions&#10;        Assert.Equal(32, UnitConverter.Convert(0, &quot;celsius&quot;, &quot;fahrenheit&quot;));&#10;        Assert.Equal(273.15, UnitConverter.Convert(0, &quot;celsius&quot;, &quot;kelvin&quot;));&#10;        Assert.Equal(100, UnitConverter.Convert(373.15, &quot;kelvin&quot;, &quot;celsius&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_FuelConsumptionConversions_WorkCorrectly()&#10;    {&#10;        // Test l/100km conversions&#10;        var mpgResult = UnitConverter.Convert(8, &quot;l/100km&quot;, &quot;mpg&quot;);&#10;        Assert.Equal(29.4, mpgResult, 1);&#10;        &#10;        var kmLResult = UnitConverter.Convert(8, &quot;l/100km&quot;, &quot;km/l&quot;);&#10;        Assert.Equal(12.5, kmLResult, 1);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Xunit;&#10;&#10;namespace TemplateEngine.Tests;&#10;&#10;public class UnitConverterTests&#10;{&#10;    [Theory]&#10;    [InlineData(&quot;km/h&quot;, &quot;mph&quot;, 100, 62.1371)]&#10;    [InlineData(&quot;km/h&quot;, &quot;m/s&quot;, 36, 10)]&#10;    [InlineData(&quot;l/100km&quot;, &quot;mpg&quot;, 8, 29.401822875)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 0, 32)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 100, 212)]&#10;    [InlineData(&quot;kg&quot;, &quot;lbs&quot;, 1, 2.20462)]&#10;    [InlineData(&quot;m&quot;, &quot;ft&quot;, 1, 3.28084)]&#10;    public void Convert_ValidConversions_ReturnsExpectedResult(string fromUnit, string toUnit, double input, double expected)&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(input, fromUnit, toUnit);&#10;        &#10;        // Assert&#10;        Assert.Equal(expected, result, 5); // 5 decimal places precision&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_InvalidConversion_ReturnsOriginalValue()&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(100, &quot;kg&quot;, &quot;mph&quot;);&#10;        &#10;        // Assert&#10;        Assert.Equal(100, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_ValidConversion_ReturnsTrue()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.True(UnitConverter.CanConvert(&quot;km/h&quot;, &quot;mph&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;l/100km&quot;, &quot;mpg&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;celsius&quot;, &quot;fahrenheit&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_InvalidConversion_ReturnsFalse()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.False(UnitConverter.CanConvert(&quot;kg&quot;, &quot;mph&quot;));&#10;        Assert.False(UnitConverter.CanConvert(&quot;nonexistent&quot;, &quot;mph&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_ValidUnit_ReturnsConversions()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;km/h&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Contains(&quot;mph&quot;, conversions);&#10;        Assert.Contains(&quot;m/s&quot;, conversions);&#10;        Assert.Contains(&quot;knots&quot;, conversions);&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_InvalidUnit_ReturnsEmpty()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;nonexistent&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Empty(conversions);&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_CaseInsensitive_WorksCorrectly()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.Equal(62.1371, UnitConverter.Convert(100, &quot;KM/H&quot;, &quot;MPH&quot;), 4);&#10;        Assert.Equal(62.1371, UnitConverter.Convert(100, &quot;km/h&quot;, &quot;MPH&quot;), 4);&#10;        Assert.Equal(62.1371, UnitConverter.Convert(100, &quot;KM/H&quot;, &quot;mph&quot;), 4);&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_AllSpeedConversions_WorkCorrectly()&#10;    {&#10;        // Test all speed conversions from km/h&#10;        Assert.Equal(27.778, UnitConverter.Convert(100, &quot;km/h&quot;, &quot;m/s&quot;), 3);&#10;        Assert.Equal(53.996, UnitConverter.Convert(100, &quot;km/h&quot;, &quot;knots&quot;), 3);&#10;        &#10;        // Test conversion precision (km/h to mph and back should be close to original)&#10;        var mph = UnitConverter.Convert(100, &quot;km/h&quot;, &quot;mph&quot;);&#10;        Assert.Equal(62.1371, mph, 4);&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_AllTemperatureConversions_WorkCorrectly()&#10;    {&#10;        // Test celsius conversions&#10;        Assert.Equal(32, UnitConverter.Convert(0, &quot;celsius&quot;, &quot;fahrenheit&quot;));&#10;        Assert.Equal(273.15, UnitConverter.Convert(0, &quot;celsius&quot;, &quot;kelvin&quot;));&#10;        &#10;        // Note: UnitConverter only supports celsius as source, not kelvin to celsius&#10;        // So we test the available conversions only&#10;        Assert.Equal(212, UnitConverter.Convert(100, &quot;celsius&quot;, &quot;fahrenheit&quot;));&#10;        Assert.Equal(373.15, UnitConverter.Convert(100, &quot;celsius&quot;, &quot;kelvin&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_FuelConsumptionConversions_WorkCorrectly()&#10;    {&#10;        // Test l/100km conversions&#10;        var mpgResult = UnitConverter.Convert(8, &quot;l/100km&quot;, &quot;mpg&quot;);&#10;        Assert.Equal(29.4, mpgResult, 1);&#10;        &#10;        var kmLResult = UnitConverter.Convert(8, &quot;l/100km&quot;, &quot;km/l&quot;);&#10;        Assert.Equal(12.5, kmLResult, 1);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/Class1.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/Class1.cs" />
              <option name="originalContent" value="using System.Text.Json;&#10;using System.Text.RegularExpressions;&#10;using System.Globalization;&#10;&#10;namespace TemplateEngine;&#10;&#10;public class TemplateItem&#10;{&#10;    public string Name { get; set; } = string.Empty;&#10;    public double? NumericValue { get; set; }&#10;    public string? StringValue { get; set; }&#10;    public string? Unit { get; set; }&#10;&#10;    public object? Value =&gt; StringValue ?? (object?)NumericValue;&#10;}&#10;&#10;public class SimpleTemplateEngine&#10;{&#10;    private readonly List&lt;TemplateItem&gt; _items;&#10;    private readonly Regex _tokenRegex = new Regex(@&quot;\{(\w+)\.(\w+)\}&quot;, RegexOptions.Compiled);&#10;&#10;    public SimpleTemplateEngine(string jsonData)&#10;    {&#10;        _items = ParseJsonData(jsonData);&#10;    }&#10;&#10;    public SimpleTemplateEngine(List&lt;TemplateItem&gt; items)&#10;    {&#10;        _items = items;&#10;    }&#10;&#10;    private List&lt;TemplateItem&gt; ParseJsonData(string jsonData)&#10;    {&#10;        var options = new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true,&#10;            PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower&#10;        };&#10;&#10;        return JsonSerializer.Deserialize&lt;List&lt;TemplateItem&gt;&gt;(jsonData, options) ?? new List&lt;TemplateItem&gt;();&#10;    }&#10;&#10;    public string ProcessTemplate(string template)&#10;    {&#10;        return _tokenRegex.Replace(template, match =&gt;&#10;        {&#10;            var itemName = match.Groups[1].Value;&#10;            var propertyName = match.Groups[2].Value.ToLowerInvariant();&#10;&#10;            var item = _items.FirstOrDefault(i =&gt; i.Name.Equals(itemName, StringComparison.OrdinalIgnoreCase));&#10;            if (item == null)&#10;                return match.Value; // Return original token if item not found&#10;&#10;            return propertyName switch&#10;            {&#10;                &quot;value&quot; =&gt; FormatValue(item.Value),&#10;                &quot;unit&quot; =&gt; item.Unit ?? string.Empty,&#10;                &quot;name&quot; =&gt; item.Name,&#10;                _ =&gt; match.Value // Return original token if property not recognized&#10;            };&#10;        });&#10;    }&#10;&#10;    private static string FormatValue(object? value)&#10;    {&#10;        return value switch&#10;        {&#10;            double d =&gt; d.ToString(CultureInfo.InvariantCulture),&#10;            float f =&gt; f.ToString(CultureInfo.InvariantCulture),&#10;            decimal dec =&gt; dec.ToString(CultureInfo.InvariantCulture),&#10;            _ =&gt; value?.ToString() ?? string.Empty&#10;        };&#10;    }&#10;&#10;    public List&lt;TemplateItem&gt; GetItems() =&gt; _items.ToList();&#10;}" />
              <option name="updatedContent" value="using System.Text.Json;&#10;using System.Text.RegularExpressions;&#10;using System.Globalization;&#10;&#10;namespace TemplateEngine;&#10;&#10;public class TemplateItem&#10;{&#10;    public string Name { get; set; } = string.Empty;&#10;    public double? NumericValue { get; set; }&#10;    public string? StringValue { get; set; }&#10;    public string? Unit { get; set; }&#10;&#10;    public object? Value =&gt; StringValue ?? (object?)NumericValue;&#10;}&#10;&#10;public class UnitConverter&#10;{&#10;    private static readonly Dictionary&lt;string, Dictionary&lt;string, Func&lt;double, double&gt;&gt;&gt; _conversions = new()&#10;    {&#10;        [&quot;km/h&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;mph&quot;] = value =&gt; value * 0.621371,&#10;            [&quot;m/s&quot;] = value =&gt; value / 3.6,&#10;            [&quot;knots&quot;] = value =&gt; value * 0.539957&#10;        },&#10;        [&quot;l/100km&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;mpg&quot;] = value =&gt; 235.214583 / value, // US gallons&#10;            [&quot;mpg_uk&quot;] = value =&gt; 282.481 / value, // UK gallons&#10;            [&quot;km/l&quot;] = value =&gt; 100 / value&#10;        },&#10;        [&quot;celsius&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;fahrenheit&quot;] = value =&gt; (value * 9 / 5) + 32,&#10;            [&quot;kelvin&quot;] = value =&gt; value + 273.15&#10;        },&#10;        [&quot;kg&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;lbs&quot;] = value =&gt; value * 2.20462,&#10;            [&quot;oz&quot;] = value =&gt; value * 35.274&#10;        },&#10;        [&quot;m&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;ft&quot;] = value =&gt; value * 3.28084,&#10;            [&quot;inches&quot;] = value =&gt; value * 39.3701,&#10;            [&quot;miles&quot;] = value =&gt; value * 0.000621371,&#10;            [&quot;km&quot;] = value =&gt; value / 1000&#10;        }&#10;    };&#10;&#10;    public static double Convert(double value, string fromUnit, string toUnit)&#10;    {&#10;        if (_conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions))&#10;        {&#10;            if (conversions.TryGetValue(toUnit.ToLowerInvariant(), out var converter))&#10;            {&#10;                return converter(value);&#10;            }&#10;        }&#10;        &#10;        // If no conversion found, return original value&#10;        return value;&#10;    }&#10;&#10;    public static bool CanConvert(string fromUnit, string toUnit)&#10;    {&#10;        return _conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions) &amp;&amp;&#10;               conversions.ContainsKey(toUnit.ToLowerInvariant());&#10;    }&#10;&#10;    public static IEnumerable&lt;string&gt; GetAvailableConversions(string fromUnit)&#10;    {&#10;        if (_conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions))&#10;        {&#10;            return conversions.Keys;&#10;        }&#10;        return Enumerable.Empty&lt;string&gt;();&#10;    }&#10;}&#10;&#10;public class SimpleTemplateEngine&#10;{&#10;    private readonly List&lt;TemplateItem&gt; _items;&#10;    private readonly Regex _tokenRegex = new Regex(@&quot;\{(\w+)\.(\w+)(?::([^}]+))?\}&quot;, RegexOptions.Compiled);&#10;&#10;    public SimpleTemplateEngine(string jsonData)&#10;    {&#10;        _items = ParseJsonData(jsonData);&#10;    }&#10;&#10;    public SimpleTemplateEngine(List&lt;TemplateItem&gt; items)&#10;    {&#10;        _items = items;&#10;    }&#10;&#10;    private List&lt;TemplateItem&gt; ParseJsonData(string jsonData)&#10;    {&#10;        var options = new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true,&#10;            PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower&#10;        };&#10;&#10;        return JsonSerializer.Deserialize&lt;List&lt;TemplateItem&gt;&gt;(jsonData, options) ?? new List&lt;TemplateItem&gt;();&#10;    }&#10;&#10;    public string ProcessTemplate(string template)&#10;    {&#10;        return _tokenRegex.Replace(template, match =&gt;&#10;        {&#10;            var itemName = match.Groups[1].Value;&#10;            var propertyName = match.Groups[2].Value.ToLowerInvariant();&#10;            var modifiers = match.Groups[3].Success ? match.Groups[3].Value : string.Empty;&#10;&#10;            var item = _items.FirstOrDefault(i =&gt; i.Name.Equals(itemName, StringComparison.OrdinalIgnoreCase));&#10;            if (item == null)&#10;                return match.Value; // Return original token if item not found&#10;&#10;            var value = propertyName switch&#10;            {&#10;                &quot;value&quot; =&gt; item.Value,&#10;                &quot;unit&quot; =&gt; item.Unit ?? string.Empty,&#10;                &quot;name&quot; =&gt; item.Name,&#10;                _ =&gt; null&#10;            };&#10;&#10;            if (value == null)&#10;                return match.Value;&#10;&#10;            if (propertyName == &quot;value&quot; &amp;&amp; !string.IsNullOrEmpty(modifiers))&#10;            {&#10;                return ProcessValueWithModifiers(value, modifiers, item.Unit);&#10;            }&#10;&#10;            return FormatValue(value);&#10;        });&#10;    }&#10;&#10;    private string ProcessValueWithModifiers(object? value, string modifiers, string? unit)&#10;    {&#10;        if (value is not double numericValue)&#10;        {&#10;            if (value is string || !double.TryParse(value?.ToString(), NumberStyles.Float, CultureInfo.InvariantCulture, out numericValue))&#10;            {&#10;                return value?.ToString() ?? string.Empty;&#10;            }&#10;        }&#10;&#10;        var currentValue = numericValue;&#10;        var currentUnit = unit?.ToLowerInvariant() ?? string.Empty;&#10;&#10;        // Parse modifiers (e.g., &quot;convert(mph):round(2)&quot;)&#10;        var modifierParts = modifiers.Split(':');&#10;        &#10;        foreach (var modifier in modifierParts)&#10;        {&#10;            var trimmedModifier = modifier.Trim();&#10;            &#10;            if (trimmedModifier.StartsWith(&quot;round(&quot;) &amp;&amp; trimmedModifier.EndsWith(&quot;)&quot;))&#10;            {&#10;                var roundParam = trimmedModifier[6..^1]; // Extract parameter between round( and )&#10;                if (int.TryParse(roundParam, out var decimals))&#10;                {&#10;                    currentValue = Math.Round(currentValue, decimals);&#10;                }&#10;            }&#10;            else if (trimmedModifier.StartsWith(&quot;convert(&quot;) &amp;&amp; trimmedModifier.EndsWith(&quot;)&quot;))&#10;            {&#10;                var convertParam = trimmedModifier[8..^1]; // Extract parameter between convert( and )&#10;                if (!string.IsNullOrEmpty(currentUnit))&#10;                {&#10;                    currentValue = UnitConverter.Convert(currentValue, currentUnit, convertParam);&#10;                    currentUnit = convertParam; // Update current unit for potential chaining&#10;                }&#10;            }&#10;        }&#10;&#10;        return currentValue.ToString(CultureInfo.InvariantCulture);&#10;    }&#10;&#10;    private static string FormatValue(object? value)&#10;    {&#10;        return value switch&#10;        {&#10;            double d =&gt; d.ToString(CultureInfo.InvariantCulture),&#10;            float f =&gt; f.ToString(CultureInfo.InvariantCulture),&#10;            decimal dec =&gt; dec.ToString(CultureInfo.InvariantCulture),&#10;            _ =&gt; value?.ToString() ?? string.Empty&#10;        };&#10;    }&#10;&#10;    public List&lt;TemplateItem&gt; GetItems() =&gt; _items.ToList();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/Modifiers/ConvertModifier.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/Modifiers/ConvertModifier.cs" />
              <option name="updatedContent" value="namespace TemplateEngine.Modifiers;&#10;&#10;/// &lt;summary&gt;&#10;/// Modifier that converts values from one unit to another using the UnitConverter.&#10;/// &lt;/summary&gt;&#10;public class ConvertModifier : IValueModifier&#10;{&#10;    public bool CanHandle(string modifierString)&#10;    {&#10;        return modifierString.StartsWith(&quot;convert(&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; &#10;               modifierString.EndsWith(&quot;)&quot;);&#10;    }&#10;&#10;    public void Apply(ModifierContext context, string modifierString)&#10;    {&#10;        var targetUnit = ExtractParameter(modifierString);&#10;        if (!string.IsNullOrEmpty(context.Unit) &amp;&amp; !string.IsNullOrEmpty(targetUnit))&#10;        {&#10;            context.Value = UnitConverter.Convert(context.Value, context.Unit, targetUnit);&#10;            context.Unit = targetUnit; // Update unit for potential chaining&#10;        }&#10;    }&#10;&#10;    private static string ExtractParameter(string modifierString)&#10;    {&#10;        return modifierString[8..^1]; // Extract between &quot;convert(&quot; and &quot;)&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/Modifiers/IValueModifier.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/Modifiers/IValueModifier.cs" />
              <option name="updatedContent" value="namespace TemplateEngine.Modifiers;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents the context for modifier processing, containing the current value and unit.&#10;/// &lt;/summary&gt;&#10;public class ModifierContext&#10;{&#10;    public double Value { get; set; }&#10;    public string Unit { get; set; } = string.Empty;&#10;&#10;    public ModifierContext(double value, string unit = &quot;&quot;)&#10;    {&#10;        Value = value;&#10;        Unit = unit;&#10;    }&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Base interface for value modifiers that can be applied to template values.&#10;/// &lt;/summary&gt;&#10;public interface IValueModifier&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Checks if this modifier can handle the given modifier string.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;modifierString&quot;&gt;The modifier string to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if this modifier can handle the string, false otherwise.&lt;/returns&gt;&#10;    bool CanHandle(string modifierString);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Applies the modification to the context.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;context&quot;&gt;The context containing the value and unit to modify.&lt;/param&gt;&#10;    /// &lt;param name=&quot;modifierString&quot;&gt;The modifier string containing parameters.&lt;/param&gt;&#10;    void Apply(ModifierContext context, string modifierString);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/Modifiers/ModifierProcessor.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/Modifiers/ModifierProcessor.cs" />
              <option name="updatedContent" value="namespace TemplateEngine.Modifiers;&#10;&#10;/// &lt;summary&gt;&#10;/// Processes value modifiers using a chain of responsibility pattern.&#10;/// &lt;/summary&gt;&#10;public class ModifierProcessor&#10;{&#10;    private readonly List&lt;IValueModifier&gt; _modifiers;&#10;&#10;    public ModifierProcessor()&#10;    {&#10;        // Register all available modifiers&#10;        _modifiers = new List&lt;IValueModifier&gt;&#10;        {&#10;            new RoundModifier(),&#10;            new ConvertModifier()&#10;        };&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Processes all modifiers in sequence for the given value and unit.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The initial value to process.&lt;/param&gt;&#10;    /// &lt;param name=&quot;unit&quot;&gt;The initial unit of the value.&lt;/param&gt;&#10;    /// &lt;param name=&quot;modifierString&quot;&gt;The modifier string containing all modifiers (e.g., &quot;convert(mph):round(2)&quot;).&lt;/param&gt;&#10;    /// &lt;returns&gt;The processed value as a string.&lt;/returns&gt;&#10;    public string ProcessModifiers(double value, string unit, string modifierString)&#10;    {&#10;        var context = new ModifierContext(value, unit);&#10;        var modifierParts = modifierString.Split(':');&#10;&#10;        foreach (var modifierPart in modifierParts)&#10;        {&#10;            var trimmedModifier = modifierPart.Trim();&#10;            if (string.IsNullOrEmpty(trimmedModifier)) continue;&#10;&#10;            var modifier = _modifiers.FirstOrDefault(m =&gt; m.CanHandle(trimmedModifier));&#10;            modifier?.Apply(context, trimmedModifier);&#10;        }&#10;&#10;        return context.Value.ToString(System.Globalization.CultureInfo.InvariantCulture);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Registers a new modifier to the processor.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;modifier&quot;&gt;The modifier to register.&lt;/param&gt;&#10;    public void RegisterModifier(IValueModifier modifier)&#10;    {&#10;        _modifiers.Add(modifier);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets all registered modifiers.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;A read-only collection of registered modifiers.&lt;/returns&gt;&#10;    public IReadOnlyList&lt;IValueModifier&gt; GetModifiers() =&gt; _modifiers.AsReadOnly();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/Modifiers/RoundModifier.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/Modifiers/RoundModifier.cs" />
              <option name="updatedContent" value="using System.Globalization;&#10;&#10;namespace TemplateEngine.Modifiers;&#10;&#10;/// &lt;summary&gt;&#10;/// Modifier that rounds numeric values to a specified number of decimal places.&#10;/// &lt;/summary&gt;&#10;public class RoundModifier : IValueModifier&#10;{&#10;    public bool CanHandle(string modifierString)&#10;    {&#10;        return modifierString.StartsWith(&quot;round(&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; &#10;               modifierString.EndsWith(&quot;)&quot;);&#10;    }&#10;&#10;    public void Apply(ModifierContext context, string modifierString)&#10;    {&#10;        var parameter = ExtractParameter(modifierString);&#10;        if (int.TryParse(parameter, out var decimals))&#10;        {&#10;            context.Value = Math.Round(context.Value, decimals);&#10;        }&#10;    }&#10;&#10;    private static string ExtractParameter(string modifierString)&#10;    {&#10;        return modifierString[6..^1]; // Extract between &quot;round(&quot; and &quot;)&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/SimpleTemplateEngine.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/SimpleTemplateEngine.cs" />
              <option name="originalContent" value="using System.Text.Json;&#10;using System.Text.RegularExpressions;&#10;using System.Globalization;&#10;using TemplateEngine.Modifiers;&#10;&#10;namespace TemplateEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// A simple template engine that processes templates with token replacement, unit conversion, and value formatting.&#10;/// &lt;/summary&gt;&#10;public class SimpleTemplateEngine&#10;{&#10;    private readonly List&lt;TemplateItem&gt; _items;&#10;    private readonly Regex _tokenRegex = new Regex(@&quot;\{(\w+)\.(\w+)(?::([^}]+))?\}&quot;, RegexOptions.Compiled);&#10;    private readonly ModifierProcessor _modifierProcessor;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the SimpleTemplateEngine with JSON data.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;jsonData&quot;&gt;JSON string containing an array of template items.&lt;/param&gt;&#10;    /// &lt;param name=&quot;configureOptions&quot;&gt;Optional action to configure JSON serialization options.&lt;/param&gt;&#10;    public SimpleTemplateEngine(string jsonData, Action&lt;JsonSerializerOptions&gt;? configureOptions = null)&#10;    {&#10;        _items = ParseJsonData(jsonData, configureOptions);&#10;        _modifierProcessor = new ModifierProcessor();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the SimpleTemplateEngine with a list of template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;items&quot;&gt;The list of template items.&lt;/param&gt;&#10;    public SimpleTemplateEngine(List&lt;TemplateItem&gt; items)&#10;    {&#10;        _items = items;&#10;        _modifierProcessor = new ModifierProcessor();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Parses JSON data into a list of template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;jsonData&quot;&gt;The JSON data to parse.&lt;/param&gt;&#10;    /// &lt;param name=&quot;configureOptions&quot;&gt;Optional action to configure JSON serialization options.&lt;/param&gt;&#10;    /// &lt;returns&gt;A list of template items.&lt;/returns&gt;&#10;    private List&lt;TemplateItem&gt; ParseJsonData(string jsonData, Action&lt;JsonSerializerOptions&gt;? configureOptions = null)&#10;    {&#10;        var options = new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true,&#10;            PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower&#10;        };&#10;&#10;        // Apply custom configuration if provided&#10;        configureOptions?.Invoke(options);&#10;&#10;        return JsonSerializer.Deserialize&lt;List&lt;TemplateItem&gt;&gt;(jsonData, options) ?? new List&lt;TemplateItem&gt;();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Processes a template string, replacing tokens with actual values.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;template&quot;&gt;The template string containing tokens to replace.&lt;/param&gt;&#10;    /// &lt;returns&gt;The processed template with tokens replaced by actual values.&lt;/returns&gt;&#10;    public string ProcessTemplate(string template)&#10;    {&#10;        return _tokenRegex.Replace(template, match =&gt;&#10;        {&#10;            var itemName = match.Groups[1].Value;&#10;            var propertyName = match.Groups[2].Value.ToLowerInvariant();&#10;            var modifiers = match.Groups[3].Success ? match.Groups[3].Value : string.Empty;&#10;&#10;            var item = _items.FirstOrDefault(i =&gt; i.Name.Equals(itemName, StringComparison.OrdinalIgnoreCase));&#10;            if (item == null)&#10;                return match.Value; // Return original token if item not found&#10;&#10;            var value = propertyName switch&#10;            {&#10;                &quot;value&quot; =&gt; item.Value,&#10;                &quot;unit&quot; =&gt; item.Unit ?? string.Empty,&#10;                &quot;name&quot; =&gt; item.Name,&#10;                _ =&gt; null&#10;            };&#10;&#10;            if (value == null)&#10;                return match.Value;&#10;&#10;            if (propertyName == &quot;value&quot; &amp;&amp; !string.IsNullOrEmpty(modifiers))&#10;            {&#10;                return ProcessValueWithModifiers(value, modifiers, item.Unit);&#10;            }&#10;&#10;            return FormatValue(value);&#10;        });&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Processes a value with the specified modifiers using the modifier processor.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to process.&lt;/param&gt;&#10;    /// &lt;param name=&quot;modifiers&quot;&gt;The modifiers to apply (e.g., &quot;convert(mph):round(2)&quot;).&lt;/param&gt;&#10;    /// &lt;param name=&quot;unit&quot;&gt;The current unit of the value.&lt;/param&gt;&#10;    /// &lt;returns&gt;The processed value as a string.&lt;/returns&gt;&#10;    private string ProcessValueWithModifiers(object? value, string modifiers, string? unit)&#10;    {&#10;        // Handle non-numeric values&#10;        if (value is double numericValue)&#10;            return _modifierProcessor.ProcessModifiers(numericValue, unit?.ToLowerInvariant() ?? string.Empty,&#10;                modifiers);&#10;        &#10;        if (value is string || !double.TryParse(value?.ToString(), NumberStyles.Float, CultureInfo.InvariantCulture, out numericValue))&#10;        {&#10;            return value?.ToString() ?? string.Empty;&#10;        }&#10;&#10;        return _modifierProcessor.ProcessModifiers(numericValue, unit?.ToLowerInvariant() ?? string.Empty, modifiers);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Registers a custom modifier with the template engine.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;modifier&quot;&gt;The custom modifier to register.&lt;/param&gt;&#10;    public void RegisterModifier(IValueModifier modifier)&#10;    {&#10;        _modifierProcessor.RegisterModifier(modifier);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Formats a value for display, ensuring culture-invariant number formatting.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to format.&lt;/param&gt;&#10;    /// &lt;returns&gt;The formatted value as a string.&lt;/returns&gt;&#10;    private static string FormatValue(object? value)&#10;    {&#10;        return value switch&#10;        {&#10;            double d =&gt; d.ToString(CultureInfo.InvariantCulture),&#10;            float f =&gt; f.ToString(CultureInfo.InvariantCulture),&#10;            decimal dec =&gt; dec.ToString(CultureInfo.InvariantCulture),&#10;            _ =&gt; value?.ToString() ?? string.Empty&#10;        };&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets a copy of all template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;A list containing copies of all template items.&lt;/returns&gt;&#10;    public List&lt;TemplateItem&gt; GetItems() =&gt; _items.ToList();&#10;}&#10;" />
              <option name="updatedContent" value="using System.Text.Json;&#10;using System.Text.RegularExpressions;&#10;using System.Globalization;&#10;using TemplateEngine.Modifiers;&#10;&#10;namespace TemplateEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// A simple template engine that processes templates with token replacement, unit conversion, and value formatting.&#10;/// &lt;/summary&gt;&#10;public class SimpleTemplateEngine&#10;{&#10;    private readonly List&lt;TemplateItem&gt; _items;&#10;    private readonly Regex _tokenRegex = new Regex(@&quot;\{\{(\w+)\.(\w+)(?::([^}]+))?\}\}&quot;, RegexOptions.Compiled);&#10;    private readonly ModifierProcessor _modifierProcessor;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the SimpleTemplateEngine with JSON data.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;jsonData&quot;&gt;JSON string containing an array of template items.&lt;/param&gt;&#10;    /// &lt;param name=&quot;configureOptions&quot;&gt;Optional action to configure JSON serialization options.&lt;/param&gt;&#10;    public SimpleTemplateEngine(string jsonData, Action&lt;JsonSerializerOptions&gt;? configureOptions = null)&#10;    {&#10;        _items = ParseJsonData(jsonData, configureOptions);&#10;        _modifierProcessor = new ModifierProcessor();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the SimpleTemplateEngine with a list of template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;items&quot;&gt;The list of template items.&lt;/param&gt;&#10;    public SimpleTemplateEngine(List&lt;TemplateItem&gt; items)&#10;    {&#10;        _items = items;&#10;        _modifierProcessor = new ModifierProcessor();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Parses JSON data into a list of template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;jsonData&quot;&gt;The JSON data to parse.&lt;/param&gt;&#10;    /// &lt;param name=&quot;configureOptions&quot;&gt;Optional action to configure JSON serialization options.&lt;/param&gt;&#10;    /// &lt;returns&gt;A list of template items.&lt;/returns&gt;&#10;    private List&lt;TemplateItem&gt; ParseJsonData(string jsonData, Action&lt;JsonSerializerOptions&gt;? configureOptions = null)&#10;    {&#10;        var options = new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true,&#10;            PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower&#10;        };&#10;&#10;        // Apply custom configuration if provided&#10;        configureOptions?.Invoke(options);&#10;&#10;        return JsonSerializer.Deserialize&lt;List&lt;TemplateItem&gt;&gt;(jsonData, options) ?? new List&lt;TemplateItem&gt;();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Processes a template string, replacing tokens with actual values.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;template&quot;&gt;The template string containing tokens to replace.&lt;/param&gt;&#10;    /// &lt;returns&gt;The processed template with tokens replaced by actual values.&lt;/returns&gt;&#10;    public string ProcessTemplate(string template)&#10;    {&#10;        return _tokenRegex.Replace(template, match =&gt;&#10;        {&#10;            var itemName = match.Groups[1].Value;&#10;            var propertyName = match.Groups[2].Value.ToLowerInvariant();&#10;            var modifiers = match.Groups[3].Success ? match.Groups[3].Value : string.Empty;&#10;&#10;            var item = _items.FirstOrDefault(i =&gt; i.Name.Equals(itemName, StringComparison.OrdinalIgnoreCase));&#10;            if (item == null)&#10;                return match.Value; // Return original token if item not found&#10;&#10;            var value = propertyName switch&#10;            {&#10;                &quot;value&quot; =&gt; item.Value,&#10;                &quot;unit&quot; =&gt; item.Unit ?? string.Empty,&#10;                &quot;name&quot; =&gt; item.Name,&#10;                _ =&gt; null&#10;            };&#10;&#10;            if (value == null)&#10;                return match.Value;&#10;&#10;            if (propertyName == &quot;value&quot; &amp;&amp; !string.IsNullOrEmpty(modifiers))&#10;            {&#10;                return ProcessValueWithModifiers(value, modifiers, item.Unit);&#10;            }&#10;&#10;            return FormatValue(value);&#10;        });&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Processes a value with the specified modifiers using the modifier processor.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to process.&lt;/param&gt;&#10;    /// &lt;param name=&quot;modifiers&quot;&gt;The modifiers to apply (e.g., &quot;convert(mph):round(2)&quot;).&lt;/param&gt;&#10;    /// &lt;param name=&quot;unit&quot;&gt;The current unit of the value.&lt;/param&gt;&#10;    /// &lt;returns&gt;The processed value as a string.&lt;/returns&gt;&#10;    private string ProcessValueWithModifiers(object? value, string modifiers, string? unit)&#10;    {&#10;        // Handle non-numeric values&#10;        if (value is double numericValue)&#10;            return _modifierProcessor.ProcessModifiers(numericValue, unit?.ToLowerInvariant() ?? string.Empty,&#10;                modifiers);&#10;        &#10;        if (value is string || !double.TryParse(value?.ToString(), NumberStyles.Float, CultureInfo.InvariantCulture, out numericValue))&#10;        {&#10;            return value?.ToString() ?? string.Empty;&#10;        }&#10;&#10;        return _modifierProcessor.ProcessModifiers(numericValue, unit?.ToLowerInvariant() ?? string.Empty, modifiers);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Registers a custom modifier with the template engine.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;modifier&quot;&gt;The custom modifier to register.&lt;/param&gt;&#10;    public void RegisterModifier(IValueModifier modifier)&#10;    {&#10;        _modifierProcessor.RegisterModifier(modifier);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Formats a value for display, ensuring culture-invariant number formatting.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to format.&lt;/param&gt;&#10;    /// &lt;returns&gt;The formatted value as a string.&lt;/returns&gt;&#10;    private static string FormatValue(object? value)&#10;    {&#10;        return value switch&#10;        {&#10;            double d =&gt; d.ToString(CultureInfo.InvariantCulture),&#10;            float f =&gt; f.ToString(CultureInfo.InvariantCulture),&#10;            decimal dec =&gt; dec.ToString(CultureInfo.InvariantCulture),&#10;            _ =&gt; value?.ToString() ?? string.Empty&#10;        };&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets a copy of all template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;A list containing copies of all template items.&lt;/returns&gt;&#10;    public List&lt;TemplateItem&gt; GetItems() =&gt; _items.ToList();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/TemplateEngine.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/TemplateEngine.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#10;        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.6.0&quot; /&gt;&#10;        &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.4.2&quot; /&gt;&#10;        &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.4.3&quot;&gt;&#10;            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#10;            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;        &lt;/PackageReference&gt;&#10;        &lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;3.2.0&quot;&gt;&#10;            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#10;            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;        &lt;/PackageReference&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#10;        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/TemplateEngineTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/TemplateEngineTests.cs" />
              <option name="originalContent" value="using Xunit;&#10;using System.Text.Json;&#10;using System.Globalization;&#10;using TemplateEngine.Modifiers;&#10;&#10;namespace TemplateEngine.Tests;&#10;&#10;public class TemplateEngineTests&#10;{&#10;    [Fact]&#10;    public void ProcessTemplate_WithNumericValue_ReplacesTokenCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;The weight is {foo.value} {foo.unit}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;The weight is 2 kg&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithStringValue_ReplacesTokenCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;string_value&quot;: &quot;electric power&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;The type is {foo.value}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;The type is electric power&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithMultipleItems_ReplacesAllTokens()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;weight&quot;,&#10;          &quot;numeric_value&quot;: 2.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }, {&#10;          &quot;name&quot;:&quot;type&quot;,&#10;          &quot;string_value&quot;: &quot;electric power&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Item: {type.value}, Weight: {weight.value} {weight.unit}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Item: electric power, Weight: 2.5 kg&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNameToken_ReplacesCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;foo&quot;, NumericValue = 42, Unit = &quot;units&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        var template = &quot;Name: {foo.name}, Value: {foo.value}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Name: foo, Value: 42&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNonExistentItem_LeavesTokenUnchanged()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Value: {bar.value}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Value: {bar.value}&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNonExistentProperty_LeavesTokenUnchanged()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Value: {foo.unknown}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Value: {foo.unknown}&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithMissingUnit_ReturnsEmptyString()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;string_value&quot;: &quot;test&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Unit: '{foo.unit}'&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Unit: ''&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void TemplateItem_Value_ReturnsStringValueWhenBothExist()&#10;    {&#10;        // Arrange&#10;        var item = new TemplateItem&#10;        {&#10;            Name = &quot;test&quot;,&#10;            StringValue = &quot;string&quot;,&#10;            NumericValue = 42&#10;        };&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;string&quot;, item.Value);&#10;    }&#10;&#10;    [Fact]&#10;    public void TemplateItem_Value_ReturnsNumericValueWhenStringIsNull()&#10;    {&#10;        // Arrange&#10;        var item = new TemplateItem&#10;        {&#10;            Name = &quot;test&quot;,&#10;            StringValue = null,&#10;            NumericValue = 42&#10;        };&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(42.0, item.Value);&#10;    }&#10;&#10;    [Fact]&#10;    public void ParseJsonData_CaseInsensitive_ParsesCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;NAME&quot;:&quot;FOO&quot;,&#10;          &quot;NUMERIC_VALUE&quot;: 123,&#10;          &quot;UNIT&quot;: &quot;KG&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;{FOO.value} {FOO.unit}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;123 KG&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithRounding_RoundsCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 123.456789, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;123.46&quot;, engine.ProcessTemplate(&quot;{speed.value:round(2)}&quot;));&#10;        Assert.Equal(&quot;123&quot;, engine.ProcessTemplate(&quot;{speed.value:round(0)}&quot;));&#10;        Assert.Equal(&quot;123.4568&quot;, engine.ProcessTemplate(&quot;{speed.value:round(4)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithUnitConversion_ConvertsCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100, Unit = &quot;km/h&quot; },&#10;            new() { Name = &quot;consumption&quot;, NumericValue = 8.5, Unit = &quot;l/100km&quot; },&#10;            new() { Name = &quot;temp&quot;, NumericValue = 25, Unit = &quot;celsius&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert - Use rounded values to avoid floating point precision issues&#10;        Assert.Equal(&quot;62.1371&quot;, engine.ProcessTemplate(&quot;{speed.value:convert(mph):round(4)}&quot;));&#10;        Assert.Equal(&quot;27.7&quot;, engine.ProcessTemplate(&quot;{consumption.value:convert(mpg):round(1)}&quot;));&#10;        Assert.Equal(&quot;77&quot;, engine.ProcessTemplate(&quot;{temp.value:convert(fahrenheit):round(0)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithConvertAndRound_AppliesInOrder()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;62.1&quot;, engine.ProcessTemplate(&quot;{speed.value:convert(mph):round(1)}&quot;));&#10;        Assert.Equal(&quot;62&quot;, engine.ProcessTemplate(&quot;{speed.value:convert(mph):round(0)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithRoundAndConvert_AppliesInOrder()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100.789, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        // First round to 101, then convert to mph&#10;        Assert.Equal(&quot;62.8&quot;, engine.ProcessTemplate(&quot;{speed.value:round(0):convert(mph):round(1)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithInvalidConversion_ReturnsOriginalValue()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;weight&quot;, NumericValue = 100, Unit = &quot;kg&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act - Try to convert kg to mph (invalid conversion)&#10;        var result = engine.ProcessTemplate(&quot;{weight.value:convert(mph)}&quot;);&#10;        &#10;        // Assert - Should return original value since conversion is not possible&#10;        Assert.Equal(&quot;100&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithStringValue_IgnoresModifiers()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;type&quot;, StringValue = &quot;electric power&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(&quot;{type.value:round(2)}&quot;);&#10;        &#10;        // Assert - String values should ignore numeric modifiers&#10;        Assert.Equal(&quot;electric power&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_ComplexTemplate_HandlesMultipleConversions()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;: &quot;car_speed&quot;,&#10;          &quot;numeric_value&quot;: 120.5,&#10;          &quot;unit&quot;: &quot;km/h&quot;&#10;        }, {&#10;          &quot;name&quot;: &quot;fuel_consumption&quot;,&#10;          &quot;numeric_value&quot;: 7.2,&#10;          &quot;unit&quot;: &quot;l/100km&quot;&#10;        }, {&#10;          &quot;name&quot;: &quot;temperature&quot;,&#10;          &quot;numeric_value&quot;: 22.5,&#10;          &quot;unit&quot;: &quot;celsius&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Speed: {car_speed.value:convert(mph):round(1)} mph, &quot; +&#10;                      &quot;Consumption: {fuel_consumption.value:convert(mpg):round(1)} mpg, &quot; +&#10;                      &quot;Temp: {temperature.value:convert(fahrenheit):round(0)}°F&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert - 22.5°C = 72.5°F, rounded to 72°F (banker's rounding)&#10;        Assert.Equal(&quot;Speed: 74.9 mph, Consumption: 32.7 mpg, Temp: 72°F&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithCustomJsonOptions_AppliesCustomConfiguration()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;myCustomName&quot;:&quot;test_item&quot;,&#10;          &quot;myCustomNumericValue&quot;: 42.5,&#10;          &quot;myCustomUnit&quot;: &quot;customUnit&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act&#10;        var engine = new SimpleTemplateEngine(jsonData, options =&gt;&#10;        {&#10;            // Override the default naming policy to use camel case&#10;            options.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;&#10;        });&#10;        &#10;        // Since we changed to camel case and the JSON properties don't match our C# properties,&#10;        // this should result in a TemplateItem with default values&#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should have one item but with default/null values since property mapping failed&#10;        Assert.Single(items);&#10;        Assert.True(string.IsNullOrEmpty(items[0].Name));&#10;        Assert.Null(items[0].NumericValue);&#10;        Assert.Null(items[0].StringValue);&#10;        Assert.Null(items[0].Unit);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithoutCustomJsonOptions_UsesDefaults()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;test_item&quot;,&#10;          &quot;numeric_value&quot;: 42.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act - No custom options provided&#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should parse correctly with default options&#10;        Assert.Single(items);&#10;        Assert.Equal(&quot;test_item&quot;, items[0].Name);&#10;        Assert.Equal(42.5, items[0].NumericValue);&#10;        Assert.Equal(&quot;kg&quot;, items[0].Unit);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithCustomJsonOptions_PreservesDefaults()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;test_item&quot;,&#10;          &quot;numeric_value&quot;: 42.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act - Custom options that don't interfere with existing functionality&#10;        var engine = new SimpleTemplateEngine(jsonData, options =&gt;&#10;        {&#10;            // Add a custom option while preserving defaults&#10;            options.AllowTrailingCommas = true;&#10;            options.ReadCommentHandling = JsonCommentHandling.Skip;&#10;        });&#10;        &#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should still work with default case insensitive and snake_case settings&#10;        Assert.Single(items);&#10;        Assert.Equal(&quot;test_item&quot;, items[0].Name);&#10;        Assert.Equal(42.5, items[0].NumericValue);&#10;        Assert.Equal(&quot;kg&quot;, items[0].Unit);&#10;    }&#10;&#10;    [Fact]&#10;    public void RegisterModifier_CustomModifier_WorksCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;test&quot;, NumericValue = 10, Unit = &quot;units&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Create a custom modifier that multiplies by 2&#10;        var customModifier = new TestMultiplyModifier();&#10;        engine.RegisterModifier(customModifier);&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(&quot;{test.value:multiply(2)}&quot;);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;20&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ModifierProcessor_ChainedCustomModifiers_WorksCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;test&quot;, NumericValue = 5.555, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Register custom modifier&#10;        engine.RegisterModifier(new TestMultiplyModifier());&#10;        &#10;        // Act - Test chaining custom modifier with existing ones&#10;        var result = engine.ProcessTemplate(&quot;{test.value:multiply(2):convert(mph):round(1)}&quot;);&#10;        &#10;        // Assert - 5.555 * 2 = 11.11 km/h -&gt; ~6.9 mph -&gt; 6.9&#10;        Assert.Equal(&quot;6.9&quot;, result);&#10;    }&#10;}&#10;&#10;// Test helper class for custom modifier&#10;public class TestMultiplyModifier : IValueModifier&#10;{&#10;    public bool CanHandle(string modifierString)&#10;    {&#10;        return modifierString.StartsWith(&quot;multiply(&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; &#10;               modifierString.EndsWith(&quot;)&quot;);&#10;    }&#10;&#10;    public void Apply(ModifierContext context, string modifierString)&#10;    {&#10;        var parameter = modifierString[9..^1]; // Extract between &quot;multiply(&quot; and &quot;)&quot;&#10;        if (double.TryParse(parameter, NumberStyles.Float, CultureInfo.InvariantCulture, out var multiplier))&#10;        {&#10;            context.Value *= multiplier;&#10;        }&#10;    }&#10;}&#10;&#10;public class UnitConverterTests&#10;{&#10;    [Theory]&#10;    [InlineData(&quot;km/h&quot;, &quot;mph&quot;, 100, 62.1371)]&#10;    [InlineData(&quot;km/h&quot;, &quot;m/s&quot;, 36, 10)]&#10;    [InlineData(&quot;l/100km&quot;, &quot;mpg&quot;, 8, 29.401822875)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 0, 32)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 100, 212)]&#10;    [InlineData(&quot;kg&quot;, &quot;lbs&quot;, 1, 2.20462)]&#10;    [InlineData(&quot;m&quot;, &quot;ft&quot;, 1, 3.28084)]&#10;    public void Convert_ValidConversions_ReturnsExpectedResult(string fromUnit, string toUnit, double input, double expected)&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(input, fromUnit, toUnit);&#10;        &#10;        // Assert&#10;        Assert.Equal(expected, result, 5); // 5 decimal places precision&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_InvalidConversion_ReturnsOriginalValue()&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(100, &quot;kg&quot;, &quot;mph&quot;);&#10;        &#10;        // Assert&#10;        Assert.Equal(100, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_ValidConversion_ReturnsTrue()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.True(UnitConverter.CanConvert(&quot;km/h&quot;, &quot;mph&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;l/100km&quot;, &quot;mpg&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;celsius&quot;, &quot;fahrenheit&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_InvalidConversion_ReturnsFalse()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.False(UnitConverter.CanConvert(&quot;kg&quot;, &quot;mph&quot;));&#10;        Assert.False(UnitConverter.CanConvert(&quot;nonexistent&quot;, &quot;mph&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_ValidUnit_ReturnsConversions()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;km/h&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Contains(&quot;mph&quot;, conversions);&#10;        Assert.Contains(&quot;m/s&quot;, conversions);&#10;        Assert.Contains(&quot;knots&quot;, conversions);&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_InvalidUnit_ReturnsEmpty()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;nonexistent&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Empty(conversions);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Xunit;&#10;using System.Text.Json;&#10;using System.Globalization;&#10;using TemplateEngine.Modifiers;&#10;&#10;namespace TemplateEngine.Tests;&#10;&#10;public class TemplateEngineTests&#10;{&#10;    [Fact]&#10;    public void ProcessTemplate_WithNumericValue_ReplacesTokenCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;The weight is {{foo.value}} {{foo.unit}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;The weight is 2 kg&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithStringValue_ReplacesTokenCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;string_value&quot;: &quot;electric power&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;The type is {{foo.value}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;The type is electric power&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithMultipleItems_ReplacesAllTokens()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;weight&quot;,&#10;          &quot;numeric_value&quot;: 2.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }, {&#10;          &quot;name&quot;:&quot;type&quot;,&#10;          &quot;string_value&quot;: &quot;electric power&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Item: {{type.value}}, Weight: {{weight.value}} {{weight.unit}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Item: electric power, Weight: 2.5 kg&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNameToken_ReplacesCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;foo&quot;, NumericValue = 42, Unit = &quot;units&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        var template = &quot;Name: {{foo.name}}, Value: {{foo.value}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Name: foo, Value: 42&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNonExistentItem_LeavesTokenUnchanged()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Value: {{bar.value}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Value: {{bar.value}}&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNonExistentProperty_LeavesTokenUnchanged()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Value: {{foo.unknown}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Value: {{foo.unknown}}&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithMissingUnit_ReturnsEmptyString()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;string_value&quot;: &quot;test&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Unit: '{{foo.unit}}'&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Unit: ''&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void TemplateItem_Value_ReturnsStringValueWhenBothExist()&#10;    {&#10;        // Arrange&#10;        var item = new TemplateItem&#10;        {&#10;            Name = &quot;test&quot;,&#10;            StringValue = &quot;string&quot;,&#10;            NumericValue = 42&#10;        };&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;string&quot;, item.Value);&#10;    }&#10;&#10;    [Fact]&#10;    public void TemplateItem_Value_ReturnsNumericValueWhenStringIsNull()&#10;    {&#10;        // Arrange&#10;        var item = new TemplateItem&#10;        {&#10;            Name = &quot;test&quot;,&#10;            StringValue = null,&#10;            NumericValue = 42&#10;        };&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(42.0, item.Value);&#10;    }&#10;&#10;    [Fact]&#10;    public void ParseJsonData_CaseInsensitive_ParsesCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;NAME&quot;:&quot;FOO&quot;,&#10;          &quot;NUMERIC_VALUE&quot;: 123,&#10;          &quot;UNIT&quot;: &quot;KG&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;{{FOO.value}} {{FOO.unit}}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;123 KG&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithRounding_RoundsCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 123.456789, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;123.46&quot;, engine.ProcessTemplate(&quot;{{speed.value:round(2)}}&quot;));&#10;        Assert.Equal(&quot;123&quot;, engine.ProcessTemplate(&quot;{{speed.value:round(0)}}&quot;));&#10;        Assert.Equal(&quot;123.4568&quot;, engine.ProcessTemplate(&quot;{{speed.value:round(4)}}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithUnitConversion_ConvertsCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100, Unit = &quot;km/h&quot; },&#10;            new() { Name = &quot;consumption&quot;, NumericValue = 8.5, Unit = &quot;l/100km&quot; },&#10;            new() { Name = &quot;temp&quot;, NumericValue = 25, Unit = &quot;celsius&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert - Use rounded values to avoid floating point precision issues&#10;        Assert.Equal(&quot;62.1371&quot;, engine.ProcessTemplate(&quot;{{speed.value:convert(mph):round(4)}}&quot;));&#10;        Assert.Equal(&quot;27.7&quot;, engine.ProcessTemplate(&quot;{{consumption.value:convert(mpg):round(1)}}&quot;));&#10;        Assert.Equal(&quot;77&quot;, engine.ProcessTemplate(&quot;{{temp.value:convert(fahrenheit):round(0)}}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithConvertAndRound_AppliesInOrder()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;62.1&quot;, engine.ProcessTemplate(&quot;{{speed.value:convert(mph):round(1)}}&quot;));&#10;        Assert.Equal(&quot;62&quot;, engine.ProcessTemplate(&quot;{{speed.value:convert(mph):round(0)}}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithRoundAndConvert_AppliesInOrder()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100.789, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        // First round to 101, then convert to mph&#10;        Assert.Equal(&quot;62.8&quot;, engine.ProcessTemplate(&quot;{{speed.value:round(0):convert(mph):round(1)}}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithInvalidConversion_ReturnsOriginalValue()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;weight&quot;, NumericValue = 100, Unit = &quot;kg&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act - Try to convert kg to mph (invalid conversion)&#10;        var result = engine.ProcessTemplate(&quot;{{weight.value:convert(mph)}}&quot;);&#10;        &#10;        // Assert - Should return original value since conversion is not possible&#10;        Assert.Equal(&quot;100&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithStringValue_IgnoresModifiers()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;type&quot;, StringValue = &quot;electric power&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(&quot;{{type.value:round(2)}}&quot;);&#10;        &#10;        // Assert - String values should ignore numeric modifiers&#10;        Assert.Equal(&quot;electric power&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_ComplexTemplate_HandlesMultipleConversions()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;: &quot;car_speed&quot;,&#10;          &quot;numeric_value&quot;: 120.5,&#10;          &quot;unit&quot;: &quot;km/h&quot;&#10;        }, {&#10;          &quot;name&quot;: &quot;fuel_consumption&quot;,&#10;          &quot;numeric_value&quot;: 7.2,&#10;          &quot;unit&quot;: &quot;l/100km&quot;&#10;        }, {&#10;          &quot;name&quot;: &quot;temperature&quot;,&#10;          &quot;numeric_value&quot;: 22.5,&#10;          &quot;unit&quot;: &quot;celsius&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Speed: {{car_speed.value:convert(mph):round(1)}} mph, &quot; +&#10;                      &quot;Consumption: {{fuel_consumption.value:convert(mpg):round(1)}} mpg, &quot; +&#10;                      &quot;Temp: {{temperature.value:convert(fahrenheit):round(0)}}°F&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert - 22.5°C = 72.5°F, rounded to 72°F (banker's rounding)&#10;        Assert.Equal(&quot;Speed: 74.9 mph, Consumption: 32.7 mpg, Temp: 72°F&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithCustomJsonOptions_AppliesCustomConfiguration()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;myCustomName&quot;:&quot;test_item&quot;,&#10;          &quot;myCustomNumericValue&quot;: 42.5,&#10;          &quot;myCustomUnit&quot;: &quot;customUnit&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act&#10;        var engine = new SimpleTemplateEngine(jsonData, options =&gt;&#10;        {&#10;            // Override the default naming policy to use camel case&#10;            options.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;&#10;        });&#10;        &#10;        // Since we changed to camel case and the JSON properties don't match our C# properties,&#10;        // this should result in a TemplateItem with default values&#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should have one item but with default/null values since property mapping failed&#10;        Assert.Single(items);&#10;        Assert.True(string.IsNullOrEmpty(items[0].Name));&#10;        Assert.Null(items[0].NumericValue);&#10;        Assert.Null(items[0].StringValue);&#10;        Assert.Null(items[0].Unit);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithoutCustomJsonOptions_UsesDefaults()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;test_item&quot;,&#10;          &quot;numeric_value&quot;: 42.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act - No custom options provided&#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should parse correctly with default options&#10;        Assert.Single(items);&#10;        Assert.Equal(&quot;test_item&quot;, items[0].Name);&#10;        Assert.Equal(42.5, items[0].NumericValue);&#10;        Assert.Equal(&quot;kg&quot;, items[0].Unit);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithCustomJsonOptions_PreservesDefaults()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;test_item&quot;,&#10;          &quot;numeric_value&quot;: 42.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act - Custom options that don't interfere with existing functionality&#10;        var engine = new SimpleTemplateEngine(jsonData, options =&gt;&#10;        {&#10;            // Add a custom option while preserving defaults&#10;            options.AllowTrailingCommas = true;&#10;            options.ReadCommentHandling = JsonCommentHandling.Skip;&#10;        });&#10;        &#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should still work with default case insensitive and snake_case settings&#10;        Assert.Single(items);&#10;        Assert.Equal(&quot;test_item&quot;, items[0].Name);&#10;        Assert.Equal(42.5, items[0].NumericValue);&#10;        Assert.Equal(&quot;kg&quot;, items[0].Unit);&#10;    }&#10;&#10;    [Fact]&#10;    public void RegisterModifier_CustomModifier_WorksCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;test&quot;, NumericValue = 10, Unit = &quot;units&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Create a custom modifier that multiplies by 2&#10;        var customModifier = new TestMultiplyModifier();&#10;        engine.RegisterModifier(customModifier);&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(&quot;{{test.value:multiply(2)}}&quot;);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;20&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ModifierProcessor_ChainedCustomModifiers_WorksCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;test&quot;, NumericValue = 5.555, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Register custom modifier&#10;        engine.RegisterModifier(new TestMultiplyModifier());&#10;        &#10;        // Act - Test chaining custom modifier with existing ones&#10;        var result = engine.ProcessTemplate(&quot;{{test.value:multiply(2):convert(mph):round(1)}}&quot;);&#10;        &#10;        // Assert - 5.555 * 2 = 11.11 km/h -&gt; ~6.9 mph -&gt; 6.9&#10;        Assert.Equal(&quot;6.9&quot;, result);&#10;    }&#10;}&#10;&#10;// Test helper class for custom modifier&#10;public class TestMultiplyModifier : IValueModifier&#10;{&#10;    public bool CanHandle(string modifierString)&#10;    {&#10;        return modifierString.StartsWith(&quot;multiply(&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; &#10;               modifierString.EndsWith(&quot;)&quot;);&#10;    }&#10;&#10;    public void Apply(ModifierContext context, string modifierString)&#10;    {&#10;        var parameter = modifierString[9..^1]; // Extract between &quot;multiply(&quot; and &quot;)&quot;&#10;        if (double.TryParse(parameter, NumberStyles.Float, CultureInfo.InvariantCulture, out var multiplier))&#10;        {&#10;            context.Value *= multiplier;&#10;        }&#10;    }&#10;}&#10;&#10;public class UnitConverterTests&#10;{&#10;    [Theory]&#10;    [InlineData(&quot;km/h&quot;, &quot;mph&quot;, 100, 62.1371)]&#10;    [InlineData(&quot;km/h&quot;, &quot;m/s&quot;, 36, 10)]&#10;    [InlineData(&quot;l/100km&quot;, &quot;mpg&quot;, 8, 29.401822875)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 0, 32)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 100, 212)]&#10;    [InlineData(&quot;kg&quot;, &quot;lbs&quot;, 1, 2.20462)]&#10;    [InlineData(&quot;m&quot;, &quot;ft&quot;, 1, 3.28084)]&#10;    public void Convert_ValidConversions_ReturnsExpectedResult(string fromUnit, string toUnit, double input, double expected)&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(input, fromUnit, toUnit);&#10;        &#10;        // Assert&#10;        Assert.Equal(expected, result, 5); // 5 decimal places precision&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_InvalidConversion_ReturnsOriginalValue()&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(100, &quot;kg&quot;, &quot;mph&quot;);&#10;        &#10;        // Assert&#10;        Assert.Equal(100, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_ValidConversion_ReturnsTrue()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.True(UnitConverter.CanConvert(&quot;km/h&quot;, &quot;mph&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;l/100km&quot;, &quot;mpg&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;celsius&quot;, &quot;fahrenheit&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_InvalidConversion_ReturnsFalse()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.False(UnitConverter.CanConvert(&quot;kg&quot;, &quot;mph&quot;));&#10;        Assert.False(UnitConverter.CanConvert(&quot;nonexistent&quot;, &quot;mph&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_ValidUnit_ReturnsConversions()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;km/h&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Contains(&quot;mph&quot;, conversions);&#10;        Assert.Contains(&quot;m/s&quot;, conversions);&#10;        Assert.Contains(&quot;knots&quot;, conversions);&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_InvalidUnit_ReturnsEmpty()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;nonexistent&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Empty(conversions);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/TemplateItem.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/TemplateItem.cs" />
              <option name="updatedContent" value="namespace TemplateEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents a template item with a name, value (either string or numeric), and optional unit.&#10;/// &lt;/summary&gt;&#10;public class TemplateItem&#10;{&#10;    /// &lt;summary&gt;&#10;    /// The name of the template item.&#10;    /// &lt;/summary&gt;&#10;    public string Name { get; set; } = string.Empty;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// The numeric value of the item, if applicable.&#10;    /// &lt;/summary&gt;&#10;    public double? NumericValue { get; set; }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// The string value of the item, if applicable.&#10;    /// &lt;/summary&gt;&#10;    public string? StringValue { get; set; }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// The unit of measurement for the value, if applicable.&#10;    /// &lt;/summary&gt;&#10;    public string? Unit { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the value, prioritizing string value over numeric value.&#10;    /// &lt;/summary&gt;&#10;    public object? Value =&gt; StringValue ?? (object?)NumericValue;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/UnitConverter.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/UnitConverter.cs" />
              <option name="updatedContent" value="namespace TemplateEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// Provides unit conversion functionality for various measurement types.&#10;/// &lt;/summary&gt;&#10;public static class UnitConverter&#10;{&#10;    private static readonly Dictionary&lt;string, Dictionary&lt;string, Func&lt;double, double&gt;&gt;&gt; _conversions = new()&#10;    {&#10;        [&quot;km/h&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;mph&quot;] = value =&gt; value * 0.621371,&#10;            [&quot;m/s&quot;] = value =&gt; value / 3.6,&#10;            [&quot;knots&quot;] = value =&gt; value * 0.539957&#10;        },&#10;        [&quot;l/100km&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;mpg&quot;] = value =&gt; 235.214583 / value, // US gallons&#10;            [&quot;mpg_uk&quot;] = value =&gt; 282.481 / value, // UK gallons&#10;            [&quot;km/l&quot;] = value =&gt; 100 / value&#10;        },&#10;        [&quot;celsius&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;fahrenheit&quot;] = value =&gt; (value * 9 / 5) + 32,&#10;            [&quot;kelvin&quot;] = value =&gt; value + 273.15&#10;        },&#10;        [&quot;kg&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;lbs&quot;] = value =&gt; value * 2.20462,&#10;            [&quot;oz&quot;] = value =&gt; value * 35.274&#10;        },&#10;        [&quot;m&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;ft&quot;] = value =&gt; value * 3.28084,&#10;            [&quot;inches&quot;] = value =&gt; value * 39.3701,&#10;            [&quot;miles&quot;] = value =&gt; value * 0.000621371,&#10;            [&quot;km&quot;] = value =&gt; value / 1000&#10;        }&#10;    };&#10;&#10;    /// &lt;summary&gt;&#10;    /// Converts a value from one unit to another.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to convert.&lt;/param&gt;&#10;    /// &lt;param name=&quot;fromUnit&quot;&gt;The source unit.&lt;/param&gt;&#10;    /// &lt;param name=&quot;toUnit&quot;&gt;The target unit.&lt;/param&gt;&#10;    /// &lt;returns&gt;The converted value, or the original value if conversion is not supported.&lt;/returns&gt;&#10;    public static double Convert(double value, string fromUnit, string toUnit)&#10;    {&#10;        if (_conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions))&#10;        {&#10;            if (conversions.TryGetValue(toUnit.ToLowerInvariant(), out var converter))&#10;            {&#10;                return converter(value);&#10;            }&#10;        }&#10;        &#10;        // If no conversion found, return original value&#10;        return value;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Checks if a conversion from one unit to another is supported.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;fromUnit&quot;&gt;The source unit.&lt;/param&gt;&#10;    /// &lt;param name=&quot;toUnit&quot;&gt;The target unit.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the conversion is supported, false otherwise.&lt;/returns&gt;&#10;    public static bool CanConvert(string fromUnit, string toUnit)&#10;    {&#10;        return _conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions) &amp;&amp;&#10;               conversions.ContainsKey(toUnit.ToLowerInvariant());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets all available conversion targets for a given source unit.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;fromUnit&quot;&gt;The source unit.&lt;/param&gt;&#10;    /// &lt;returns&gt;An enumerable of available target units.&lt;/returns&gt;&#10;    public static IEnumerable&lt;string&gt; GetAvailableConversions(string fromUnit)&#10;    {&#10;        if (_conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions))&#10;        {&#10;            return conversions.Keys;&#10;        }&#10;        return Enumerable.Empty&lt;string&gt;();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>