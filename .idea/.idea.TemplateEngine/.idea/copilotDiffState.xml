<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/TemplateEngine/Class1.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/Class1.cs" />
              <option name="originalContent" value="using System.Text.Json;&#10;using System.Text.RegularExpressions;&#10;using System.Globalization;&#10;&#10;namespace TemplateEngine;&#10;&#10;public class TemplateItem&#10;{&#10;    public string Name { get; set; } = string.Empty;&#10;    public double? NumericValue { get; set; }&#10;    public string? StringValue { get; set; }&#10;    public string? Unit { get; set; }&#10;&#10;    public object? Value =&gt; StringValue ?? (object?)NumericValue;&#10;}&#10;&#10;public class SimpleTemplateEngine&#10;{&#10;    private readonly List&lt;TemplateItem&gt; _items;&#10;    private readonly Regex _tokenRegex = new Regex(@&quot;\{(\w+)\.(\w+)\}&quot;, RegexOptions.Compiled);&#10;&#10;    public SimpleTemplateEngine(string jsonData)&#10;    {&#10;        _items = ParseJsonData(jsonData);&#10;    }&#10;&#10;    public SimpleTemplateEngine(List&lt;TemplateItem&gt; items)&#10;    {&#10;        _items = items;&#10;    }&#10;&#10;    private List&lt;TemplateItem&gt; ParseJsonData(string jsonData)&#10;    {&#10;        var options = new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true,&#10;            PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower&#10;        };&#10;&#10;        return JsonSerializer.Deserialize&lt;List&lt;TemplateItem&gt;&gt;(jsonData, options) ?? new List&lt;TemplateItem&gt;();&#10;    }&#10;&#10;    public string ProcessTemplate(string template)&#10;    {&#10;        return _tokenRegex.Replace(template, match =&gt;&#10;        {&#10;            var itemName = match.Groups[1].Value;&#10;            var propertyName = match.Groups[2].Value.ToLowerInvariant();&#10;&#10;            var item = _items.FirstOrDefault(i =&gt; i.Name.Equals(itemName, StringComparison.OrdinalIgnoreCase));&#10;            if (item == null)&#10;                return match.Value; // Return original token if item not found&#10;&#10;            return propertyName switch&#10;            {&#10;                &quot;value&quot; =&gt; FormatValue(item.Value),&#10;                &quot;unit&quot; =&gt; item.Unit ?? string.Empty,&#10;                &quot;name&quot; =&gt; item.Name,&#10;                _ =&gt; match.Value // Return original token if property not recognized&#10;            };&#10;        });&#10;    }&#10;&#10;    private static string FormatValue(object? value)&#10;    {&#10;        return value switch&#10;        {&#10;            double d =&gt; d.ToString(CultureInfo.InvariantCulture),&#10;            float f =&gt; f.ToString(CultureInfo.InvariantCulture),&#10;            decimal dec =&gt; dec.ToString(CultureInfo.InvariantCulture),&#10;            _ =&gt; value?.ToString() ?? string.Empty&#10;        };&#10;    }&#10;&#10;    public List&lt;TemplateItem&gt; GetItems() =&gt; _items.ToList();&#10;}" />
              <option name="updatedContent" value="using System.Text.Json;&#10;using System.Text.RegularExpressions;&#10;using System.Globalization;&#10;&#10;namespace TemplateEngine;&#10;&#10;public class TemplateItem&#10;{&#10;    public string Name { get; set; } = string.Empty;&#10;    public double? NumericValue { get; set; }&#10;    public string? StringValue { get; set; }&#10;    public string? Unit { get; set; }&#10;&#10;    public object? Value =&gt; StringValue ?? (object?)NumericValue;&#10;}&#10;&#10;public class UnitConverter&#10;{&#10;    private static readonly Dictionary&lt;string, Dictionary&lt;string, Func&lt;double, double&gt;&gt;&gt; _conversions = new()&#10;    {&#10;        [&quot;km/h&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;mph&quot;] = value =&gt; value * 0.621371,&#10;            [&quot;m/s&quot;] = value =&gt; value / 3.6,&#10;            [&quot;knots&quot;] = value =&gt; value * 0.539957&#10;        },&#10;        [&quot;l/100km&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;mpg&quot;] = value =&gt; 235.214583 / value, // US gallons&#10;            [&quot;mpg_uk&quot;] = value =&gt; 282.481 / value, // UK gallons&#10;            [&quot;km/l&quot;] = value =&gt; 100 / value&#10;        },&#10;        [&quot;celsius&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;fahrenheit&quot;] = value =&gt; (value * 9 / 5) + 32,&#10;            [&quot;kelvin&quot;] = value =&gt; value + 273.15&#10;        },&#10;        [&quot;kg&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;lbs&quot;] = value =&gt; value * 2.20462,&#10;            [&quot;oz&quot;] = value =&gt; value * 35.274&#10;        },&#10;        [&quot;m&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;ft&quot;] = value =&gt; value * 3.28084,&#10;            [&quot;inches&quot;] = value =&gt; value * 39.3701,&#10;            [&quot;miles&quot;] = value =&gt; value * 0.000621371,&#10;            [&quot;km&quot;] = value =&gt; value / 1000&#10;        }&#10;    };&#10;&#10;    public static double Convert(double value, string fromUnit, string toUnit)&#10;    {&#10;        if (_conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions))&#10;        {&#10;            if (conversions.TryGetValue(toUnit.ToLowerInvariant(), out var converter))&#10;            {&#10;                return converter(value);&#10;            }&#10;        }&#10;        &#10;        // If no conversion found, return original value&#10;        return value;&#10;    }&#10;&#10;    public static bool CanConvert(string fromUnit, string toUnit)&#10;    {&#10;        return _conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions) &amp;&amp;&#10;               conversions.ContainsKey(toUnit.ToLowerInvariant());&#10;    }&#10;&#10;    public static IEnumerable&lt;string&gt; GetAvailableConversions(string fromUnit)&#10;    {&#10;        if (_conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions))&#10;        {&#10;            return conversions.Keys;&#10;        }&#10;        return Enumerable.Empty&lt;string&gt;();&#10;    }&#10;}&#10;&#10;public class SimpleTemplateEngine&#10;{&#10;    private readonly List&lt;TemplateItem&gt; _items;&#10;    private readonly Regex _tokenRegex = new Regex(@&quot;\{(\w+)\.(\w+)(?::([^}]+))?\}&quot;, RegexOptions.Compiled);&#10;&#10;    public SimpleTemplateEngine(string jsonData)&#10;    {&#10;        _items = ParseJsonData(jsonData);&#10;    }&#10;&#10;    public SimpleTemplateEngine(List&lt;TemplateItem&gt; items)&#10;    {&#10;        _items = items;&#10;    }&#10;&#10;    private List&lt;TemplateItem&gt; ParseJsonData(string jsonData)&#10;    {&#10;        var options = new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true,&#10;            PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower&#10;        };&#10;&#10;        return JsonSerializer.Deserialize&lt;List&lt;TemplateItem&gt;&gt;(jsonData, options) ?? new List&lt;TemplateItem&gt;();&#10;    }&#10;&#10;    public string ProcessTemplate(string template)&#10;    {&#10;        return _tokenRegex.Replace(template, match =&gt;&#10;        {&#10;            var itemName = match.Groups[1].Value;&#10;            var propertyName = match.Groups[2].Value.ToLowerInvariant();&#10;            var modifiers = match.Groups[3].Success ? match.Groups[3].Value : string.Empty;&#10;&#10;            var item = _items.FirstOrDefault(i =&gt; i.Name.Equals(itemName, StringComparison.OrdinalIgnoreCase));&#10;            if (item == null)&#10;                return match.Value; // Return original token if item not found&#10;&#10;            var value = propertyName switch&#10;            {&#10;                &quot;value&quot; =&gt; item.Value,&#10;                &quot;unit&quot; =&gt; item.Unit ?? string.Empty,&#10;                &quot;name&quot; =&gt; item.Name,&#10;                _ =&gt; null&#10;            };&#10;&#10;            if (value == null)&#10;                return match.Value;&#10;&#10;            if (propertyName == &quot;value&quot; &amp;&amp; !string.IsNullOrEmpty(modifiers))&#10;            {&#10;                return ProcessValueWithModifiers(value, modifiers, item.Unit);&#10;            }&#10;&#10;            return FormatValue(value);&#10;        });&#10;    }&#10;&#10;    private string ProcessValueWithModifiers(object? value, string modifiers, string? unit)&#10;    {&#10;        if (value is not double numericValue)&#10;        {&#10;            if (value is string || !double.TryParse(value?.ToString(), NumberStyles.Float, CultureInfo.InvariantCulture, out numericValue))&#10;            {&#10;                return value?.ToString() ?? string.Empty;&#10;            }&#10;        }&#10;&#10;        var currentValue = numericValue;&#10;        var currentUnit = unit?.ToLowerInvariant() ?? string.Empty;&#10;&#10;        // Parse modifiers (e.g., &quot;convert(mph):round(2)&quot;)&#10;        var modifierParts = modifiers.Split(':');&#10;        &#10;        foreach (var modifier in modifierParts)&#10;        {&#10;            var trimmedModifier = modifier.Trim();&#10;            &#10;            if (trimmedModifier.StartsWith(&quot;round(&quot;) &amp;&amp; trimmedModifier.EndsWith(&quot;)&quot;))&#10;            {&#10;                var roundParam = trimmedModifier[6..^1]; // Extract parameter between round( and )&#10;                if (int.TryParse(roundParam, out var decimals))&#10;                {&#10;                    currentValue = Math.Round(currentValue, decimals);&#10;                }&#10;            }&#10;            else if (trimmedModifier.StartsWith(&quot;convert(&quot;) &amp;&amp; trimmedModifier.EndsWith(&quot;)&quot;))&#10;            {&#10;                var convertParam = trimmedModifier[8..^1]; // Extract parameter between convert( and )&#10;                if (!string.IsNullOrEmpty(currentUnit))&#10;                {&#10;                    currentValue = UnitConverter.Convert(currentValue, currentUnit, convertParam);&#10;                    currentUnit = convertParam; // Update current unit for potential chaining&#10;                }&#10;            }&#10;        }&#10;&#10;        return currentValue.ToString(CultureInfo.InvariantCulture);&#10;    }&#10;&#10;    private static string FormatValue(object? value)&#10;    {&#10;        return value switch&#10;        {&#10;            double d =&gt; d.ToString(CultureInfo.InvariantCulture),&#10;            float f =&gt; f.ToString(CultureInfo.InvariantCulture),&#10;            decimal dec =&gt; dec.ToString(CultureInfo.InvariantCulture),&#10;            _ =&gt; value?.ToString() ?? string.Empty&#10;        };&#10;    }&#10;&#10;    public List&lt;TemplateItem&gt; GetItems() =&gt; _items.ToList();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/SimpleTemplateEngine.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/SimpleTemplateEngine.cs" />
              <option name="originalContent" value="using System.Text.Json;&#10;using System.Text.RegularExpressions;&#10;using System.Globalization;&#10;&#10;namespace TemplateEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// A simple template engine that processes templates with token replacement, unit conversion, and value formatting.&#10;/// &lt;/summary&gt;&#10;public class SimpleTemplateEngine&#10;{&#10;    private readonly List&lt;TemplateItem&gt; _items;&#10;    private readonly Regex _tokenRegex = new Regex(@&quot;\{(\w+)\.(\w+)(?::([^}]+))?\}&quot;, RegexOptions.Compiled);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the SimpleTemplateEngine with JSON data.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;jsonData&quot;&gt;JSON string containing an array of template items.&lt;/param&gt;&#10;    public SimpleTemplateEngine(string jsonData)&#10;    {&#10;        _items = ParseJsonData(jsonData);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the SimpleTemplateEngine with a list of template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;items&quot;&gt;The list of template items.&lt;/param&gt;&#10;    public SimpleTemplateEngine(List&lt;TemplateItem&gt; items)&#10;    {&#10;        _items = items;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Parses JSON data into a list of template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;jsonData&quot;&gt;The JSON data to parse.&lt;/param&gt;&#10;    /// &lt;returns&gt;A list of template items.&lt;/returns&gt;&#10;    private List&lt;TemplateItem&gt; ParseJsonData(string jsonData)&#10;    {&#10;        var options = new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true,&#10;            PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower&#10;        };&#10;&#10;        return JsonSerializer.Deserialize&lt;List&lt;TemplateItem&gt;&gt;(jsonData, options) ?? new List&lt;TemplateItem&gt;();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Processes a template string, replacing tokens with actual values.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;template&quot;&gt;The template string containing tokens to replace.&lt;/param&gt;&#10;    /// &lt;returns&gt;The processed template with tokens replaced by actual values.&lt;/returns&gt;&#10;    public string ProcessTemplate(string template)&#10;    {&#10;        return _tokenRegex.Replace(template, match =&gt;&#10;        {&#10;            var itemName = match.Groups[1].Value;&#10;            var propertyName = match.Groups[2].Value.ToLowerInvariant();&#10;            var modifiers = match.Groups[3].Success ? match.Groups[3].Value : string.Empty;&#10;&#10;            var item = _items.FirstOrDefault(i =&gt; i.Name.Equals(itemName, StringComparison.OrdinalIgnoreCase));&#10;            if (item == null)&#10;                return match.Value; // Return original token if item not found&#10;&#10;            var value = propertyName switch&#10;            {&#10;                &quot;value&quot; =&gt; item.Value,&#10;                &quot;unit&quot; =&gt; item.Unit ?? string.Empty,&#10;                &quot;name&quot; =&gt; item.Name,&#10;                _ =&gt; null&#10;            };&#10;&#10;            if (value == null)&#10;                return match.Value;&#10;&#10;            if (propertyName == &quot;value&quot; &amp;&amp; !string.IsNullOrEmpty(modifiers))&#10;            {&#10;                return ProcessValueWithModifiers(value, modifiers, item.Unit);&#10;            }&#10;&#10;            return FormatValue(value);&#10;        });&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Processes a value with the specified modifiers (rounding, conversion, etc.).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to process.&lt;/param&gt;&#10;    /// &lt;param name=&quot;modifiers&quot;&gt;The modifiers to apply (e.g., &quot;convert(mph):round(2)&quot;).&lt;/param&gt;&#10;    /// &lt;param name=&quot;unit&quot;&gt;The current unit of the value.&lt;/param&gt;&#10;    /// &lt;returns&gt;The processed value as a string.&lt;/returns&gt;&#10;    private string ProcessValueWithModifiers(object? value, string modifiers, string? unit)&#10;    {&#10;        if (value is not double numericValue)&#10;        {&#10;            if (value is string || !double.TryParse(value?.ToString(), NumberStyles.Float, CultureInfo.InvariantCulture, out numericValue))&#10;            {&#10;                return value?.ToString() ?? string.Empty;&#10;            }&#10;        }&#10;&#10;        var currentValue = numericValue;&#10;        var currentUnit = unit?.ToLowerInvariant() ?? string.Empty;&#10;&#10;        // Parse modifiers (e.g., &quot;convert(mph):round(2)&quot;)&#10;        var modifierParts = modifiers.Split(':');&#10;        &#10;        foreach (var modifier in modifierParts)&#10;        {&#10;            var trimmedModifier = modifier.Trim();&#10;            &#10;            if (trimmedModifier.StartsWith(&quot;round(&quot;) &amp;&amp; trimmedModifier.EndsWith(&quot;)&quot;))&#10;            {&#10;                var roundParam = trimmedModifier[6..^1]; // Extract parameter between round( and )&#10;                if (int.TryParse(roundParam, out var decimals))&#10;                {&#10;                    currentValue = Math.Round(currentValue, decimals);&#10;                }&#10;            }&#10;            else if (trimmedModifier.StartsWith(&quot;convert(&quot;) &amp;&amp; trimmedModifier.EndsWith(&quot;)&quot;))&#10;            {&#10;                var convertParam = trimmedModifier[8..^1]; // Extract parameter between convert( and )&#10;                if (!string.IsNullOrEmpty(currentUnit))&#10;                {&#10;                    currentValue = UnitConverter.Convert(currentValue, currentUnit, convertParam);&#10;                    currentUnit = convertParam; // Update current unit for potential chaining&#10;                }&#10;            }&#10;        }&#10;&#10;        return currentValue.ToString(CultureInfo.InvariantCulture);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Formats a value for display, ensuring culture-invariant number formatting.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to format.&lt;/param&gt;&#10;    /// &lt;returns&gt;The formatted value as a string.&lt;/returns&gt;&#10;    private static string FormatValue(object? value)&#10;    {&#10;        return value switch&#10;        {&#10;            double d =&gt; d.ToString(CultureInfo.InvariantCulture),&#10;            float f =&gt; f.ToString(CultureInfo.InvariantCulture),&#10;            decimal dec =&gt; dec.ToString(CultureInfo.InvariantCulture),&#10;            _ =&gt; value?.ToString() ?? string.Empty&#10;        };&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets a copy of all template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;A list containing copies of all template items.&lt;/returns&gt;&#10;    public List&lt;TemplateItem&gt; GetItems() =&gt; _items.ToList();&#10;}&#10;" />
              <option name="updatedContent" value="using System.Text.Json;&#10;using System.Text.RegularExpressions;&#10;using System.Globalization;&#10;&#10;namespace TemplateEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// A simple template engine that processes templates with token replacement, unit conversion, and value formatting.&#10;/// &lt;/summary&gt;&#10;public class SimpleTemplateEngine&#10;{&#10;    private readonly List&lt;TemplateItem&gt; _items;&#10;    private readonly Regex _tokenRegex = new Regex(@&quot;\{(\w+)\.(\w+)(?::([^}]+))?\}&quot;, RegexOptions.Compiled);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the SimpleTemplateEngine with JSON data.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;jsonData&quot;&gt;JSON string containing an array of template items.&lt;/param&gt;&#10;    /// &lt;param name=&quot;configureOptions&quot;&gt;Optional action to configure JSON serialization options.&lt;/param&gt;&#10;    public SimpleTemplateEngine(string jsonData, Action&lt;JsonSerializerOptions&gt;? configureOptions = null)&#10;    {&#10;        _items = ParseJsonData(jsonData, configureOptions);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the SimpleTemplateEngine with a list of template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;items&quot;&gt;The list of template items.&lt;/param&gt;&#10;    public SimpleTemplateEngine(List&lt;TemplateItem&gt; items)&#10;    {&#10;        _items = items;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Parses JSON data into a list of template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;jsonData&quot;&gt;The JSON data to parse.&lt;/param&gt;&#10;    /// &lt;param name=&quot;configureOptions&quot;&gt;Optional action to configure JSON serialization options.&lt;/param&gt;&#10;    /// &lt;returns&gt;A list of template items.&lt;/returns&gt;&#10;    private List&lt;TemplateItem&gt; ParseJsonData(string jsonData, Action&lt;JsonSerializerOptions&gt;? configureOptions = null)&#10;    {&#10;        var options = new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true,&#10;            PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower&#10;        };&#10;&#10;        // Apply custom configuration if provided&#10;        configureOptions?.Invoke(options);&#10;&#10;        return JsonSerializer.Deserialize&lt;List&lt;TemplateItem&gt;&gt;(jsonData, options) ?? new List&lt;TemplateItem&gt;();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Processes a template string, replacing tokens with actual values.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;template&quot;&gt;The template string containing tokens to replace.&lt;/param&gt;&#10;    /// &lt;returns&gt;The processed template with tokens replaced by actual values.&lt;/returns&gt;&#10;    public string ProcessTemplate(string template)&#10;    {&#10;        return _tokenRegex.Replace(template, match =&gt;&#10;        {&#10;            var itemName = match.Groups[1].Value;&#10;            var propertyName = match.Groups[2].Value.ToLowerInvariant();&#10;            var modifiers = match.Groups[3].Success ? match.Groups[3].Value : string.Empty;&#10;&#10;            var item = _items.FirstOrDefault(i =&gt; i.Name.Equals(itemName, StringComparison.OrdinalIgnoreCase));&#10;            if (item == null)&#10;                return match.Value; // Return original token if item not found&#10;&#10;            var value = propertyName switch&#10;            {&#10;                &quot;value&quot; =&gt; item.Value,&#10;                &quot;unit&quot; =&gt; item.Unit ?? string.Empty,&#10;                &quot;name&quot; =&gt; item.Name,&#10;                _ =&gt; null&#10;            };&#10;&#10;            if (value == null)&#10;                return match.Value;&#10;&#10;            if (propertyName == &quot;value&quot; &amp;&amp; !string.IsNullOrEmpty(modifiers))&#10;            {&#10;                return ProcessValueWithModifiers(value, modifiers, item.Unit);&#10;            }&#10;&#10;            return FormatValue(value);&#10;        });&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Processes a value with the specified modifiers (rounding, conversion, etc.).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to process.&lt;/param&gt;&#10;    /// &lt;param name=&quot;modifiers&quot;&gt;The modifiers to apply (e.g., &quot;convert(mph):round(2)&quot;).&lt;/param&gt;&#10;    /// &lt;param name=&quot;unit&quot;&gt;The current unit of the value.&lt;/param&gt;&#10;    /// &lt;returns&gt;The processed value as a string.&lt;/returns&gt;&#10;    private string ProcessValueWithModifiers(object? value, string modifiers, string? unit)&#10;    {&#10;        if (value is not double numericValue)&#10;        {&#10;            if (value is string || !double.TryParse(value?.ToString(), NumberStyles.Float, CultureInfo.InvariantCulture, out numericValue))&#10;            {&#10;                return value?.ToString() ?? string.Empty;&#10;            }&#10;        }&#10;&#10;        var currentValue = numericValue;&#10;        var currentUnit = unit?.ToLowerInvariant() ?? string.Empty;&#10;&#10;        // Parse modifiers (e.g., &quot;convert(mph):round(2)&quot;)&#10;        var modifierParts = modifiers.Split(':');&#10;        &#10;        foreach (var modifier in modifierParts)&#10;        {&#10;            var trimmedModifier = modifier.Trim();&#10;            &#10;            if (trimmedModifier.StartsWith(&quot;round(&quot;) &amp;&amp; trimmedModifier.EndsWith(&quot;)&quot;))&#10;            {&#10;                var roundParam = trimmedModifier[6..^1]; // Extract parameter between round( and )&#10;                if (int.TryParse(roundParam, out var decimals))&#10;                {&#10;                    currentValue = Math.Round(currentValue, decimals);&#10;                }&#10;            }&#10;            else if (trimmedModifier.StartsWith(&quot;convert(&quot;) &amp;&amp; trimmedModifier.EndsWith(&quot;)&quot;))&#10;            {&#10;                var convertParam = trimmedModifier[8..^1]; // Extract parameter between convert( and )&#10;                if (!string.IsNullOrEmpty(currentUnit))&#10;                {&#10;                    currentValue = UnitConverter.Convert(currentValue, currentUnit, convertParam);&#10;                    currentUnit = convertParam; // Update current unit for potential chaining&#10;                }&#10;            }&#10;        }&#10;&#10;        return currentValue.ToString(CultureInfo.InvariantCulture);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Formats a value for display, ensuring culture-invariant number formatting.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to format.&lt;/param&gt;&#10;    /// &lt;returns&gt;The formatted value as a string.&lt;/returns&gt;&#10;    private static string FormatValue(object? value)&#10;    {&#10;        return value switch&#10;        {&#10;            double d =&gt; d.ToString(CultureInfo.InvariantCulture),&#10;            float f =&gt; f.ToString(CultureInfo.InvariantCulture),&#10;            decimal dec =&gt; dec.ToString(CultureInfo.InvariantCulture),&#10;            _ =&gt; value?.ToString() ?? string.Empty&#10;        };&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets a copy of all template items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;A list containing copies of all template items.&lt;/returns&gt;&#10;    public List&lt;TemplateItem&gt; GetItems() =&gt; _items.ToList();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/TemplateEngine.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/TemplateEngine.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#10;        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#10;        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.6.0&quot; /&gt;&#10;        &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.4.2&quot; /&gt;&#10;        &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.4.3&quot;&gt;&#10;            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#10;            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;        &lt;/PackageReference&gt;&#10;        &lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;3.2.0&quot;&gt;&#10;            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#10;            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;        &lt;/PackageReference&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/TemplateEngineTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/TemplateEngineTests.cs" />
              <option name="originalContent" value="using Xunit;&#10;using System.Text.Json;&#10;&#10;namespace TemplateEngine.Tests;&#10;&#10;public class TemplateEngineTests&#10;{&#10;    [Fact]&#10;    public void ProcessTemplate_WithNumericValue_ReplacesTokenCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;The weight is {foo.value} {foo.unit}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;The weight is 2 kg&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithStringValue_ReplacesTokenCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;string_value&quot;: &quot;electric power&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;The type is {foo.value}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;The type is electric power&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithMultipleItems_ReplacesAllTokens()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;weight&quot;,&#10;          &quot;numeric_value&quot;: 2.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }, {&#10;          &quot;name&quot;:&quot;type&quot;,&#10;          &quot;string_value&quot;: &quot;electric power&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Item: {type.value}, Weight: {weight.value} {weight.unit}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Item: electric power, Weight: 2.5 kg&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNameToken_ReplacesCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;foo&quot;, NumericValue = 42, Unit = &quot;units&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        var template = &quot;Name: {foo.name}, Value: {foo.value}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Name: foo, Value: 42&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNonExistentItem_LeavesTokenUnchanged()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Value: {bar.value}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Value: {bar.value}&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNonExistentProperty_LeavesTokenUnchanged()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Value: {foo.unknown}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Value: {foo.unknown}&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithMissingUnit_ReturnsEmptyString()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;string_value&quot;: &quot;test&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Unit: '{foo.unit}'&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Unit: ''&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void TemplateItem_Value_ReturnsStringValueWhenBothExist()&#10;    {&#10;        // Arrange&#10;        var item = new TemplateItem&#10;        {&#10;            Name = &quot;test&quot;,&#10;            StringValue = &quot;string&quot;,&#10;            NumericValue = 42&#10;        };&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;string&quot;, item.Value);&#10;    }&#10;&#10;    [Fact]&#10;    public void TemplateItem_Value_ReturnsNumericValueWhenStringIsNull()&#10;    {&#10;        // Arrange&#10;        var item = new TemplateItem&#10;        {&#10;            Name = &quot;test&quot;,&#10;            StringValue = null,&#10;            NumericValue = 42&#10;        };&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(42.0, item.Value);&#10;    }&#10;&#10;    [Fact]&#10;    public void ParseJsonData_CaseInsensitive_ParsesCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;NAME&quot;:&quot;FOO&quot;,&#10;          &quot;NUMERIC_VALUE&quot;: 123,&#10;          &quot;UNIT&quot;: &quot;KG&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;{FOO.value} {FOO.unit}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;123 KG&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithRounding_RoundsCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 123.456789, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;123.46&quot;, engine.ProcessTemplate(&quot;{speed.value:round(2)}&quot;));&#10;        Assert.Equal(&quot;123&quot;, engine.ProcessTemplate(&quot;{speed.value:round(0)}&quot;));&#10;        Assert.Equal(&quot;123.4568&quot;, engine.ProcessTemplate(&quot;{speed.value:round(4)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithUnitConversion_ConvertsCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100, Unit = &quot;km/h&quot; },&#10;            new() { Name = &quot;consumption&quot;, NumericValue = 8.5, Unit = &quot;l/100km&quot; },&#10;            new() { Name = &quot;temp&quot;, NumericValue = 25, Unit = &quot;celsius&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert - Use rounded values to avoid floating point precision issues&#10;        Assert.Equal(&quot;62.1371&quot;, engine.ProcessTemplate(&quot;{speed.value:convert(mph):round(4)}&quot;));&#10;        Assert.Equal(&quot;27.7&quot;, engine.ProcessTemplate(&quot;{consumption.value:convert(mpg):round(1)}&quot;));&#10;        Assert.Equal(&quot;77&quot;, engine.ProcessTemplate(&quot;{temp.value:convert(fahrenheit):round(0)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithConvertAndRound_AppliesInOrder()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;62.1&quot;, engine.ProcessTemplate(&quot;{speed.value:convert(mph):round(1)}&quot;));&#10;        Assert.Equal(&quot;62&quot;, engine.ProcessTemplate(&quot;{speed.value:convert(mph):round(0)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithRoundAndConvert_AppliesInOrder()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100.789, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        // First round to 101, then convert to mph&#10;        Assert.Equal(&quot;62.8&quot;, engine.ProcessTemplate(&quot;{speed.value:round(0):convert(mph):round(1)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithInvalidConversion_ReturnsOriginalValue()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;weight&quot;, NumericValue = 100, Unit = &quot;kg&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act - Try to convert kg to mph (invalid conversion)&#10;        var result = engine.ProcessTemplate(&quot;{weight.value:convert(mph)}&quot;);&#10;        &#10;        // Assert - Should return original value since conversion is not possible&#10;        Assert.Equal(&quot;100&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithStringValue_IgnoresModifiers()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;type&quot;, StringValue = &quot;electric power&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(&quot;{type.value:round(2)}&quot;);&#10;        &#10;        // Assert - String values should ignore numeric modifiers&#10;        Assert.Equal(&quot;electric power&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_ComplexTemplate_HandlesMultipleConversions()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;: &quot;car_speed&quot;,&#10;          &quot;numeric_value&quot;: 120.5,&#10;          &quot;unit&quot;: &quot;km/h&quot;&#10;        }, {&#10;          &quot;name&quot;: &quot;fuel_consumption&quot;,&#10;          &quot;numeric_value&quot;: 7.2,&#10;          &quot;unit&quot;: &quot;l/100km&quot;&#10;        }, {&#10;          &quot;name&quot;: &quot;temperature&quot;,&#10;          &quot;numeric_value&quot;: 22.5,&#10;          &quot;unit&quot;: &quot;celsius&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Speed: {car_speed.value:convert(mph):round(1)} mph, &quot; +&#10;                      &quot;Consumption: {fuel_consumption.value:convert(mpg):round(1)} mpg, &quot; +&#10;                      &quot;Temp: {temperature.value:convert(fahrenheit):round(0)}°F&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert - 22.5°C = 72.5°F, rounded to 72°F (banker's rounding)&#10;        Assert.Equal(&quot;Speed: 74.9 mph, Consumption: 32.7 mpg, Temp: 72°F&quot;, result);&#10;    }&#10;}&#10;&#10;public class UnitConverterTests&#10;{&#10;    [Theory]&#10;    [InlineData(&quot;km/h&quot;, &quot;mph&quot;, 100, 62.1371)]&#10;    [InlineData(&quot;km/h&quot;, &quot;m/s&quot;, 36, 10)]&#10;    [InlineData(&quot;l/100km&quot;, &quot;mpg&quot;, 8, 29.401822875)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 0, 32)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 100, 212)]&#10;    [InlineData(&quot;kg&quot;, &quot;lbs&quot;, 1, 2.20462)]&#10;    [InlineData(&quot;m&quot;, &quot;ft&quot;, 1, 3.28084)]&#10;    public void Convert_ValidConversions_ReturnsExpectedResult(string fromUnit, string toUnit, double input, double expected)&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(input, fromUnit, toUnit);&#10;        &#10;        // Assert&#10;        Assert.Equal(expected, result, 5); // 5 decimal places precision&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_InvalidConversion_ReturnsOriginalValue()&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(100, &quot;kg&quot;, &quot;mph&quot;);&#10;        &#10;        // Assert&#10;        Assert.Equal(100, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_ValidConversion_ReturnsTrue()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.True(UnitConverter.CanConvert(&quot;km/h&quot;, &quot;mph&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;l/100km&quot;, &quot;mpg&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;celsius&quot;, &quot;fahrenheit&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_InvalidConversion_ReturnsFalse()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.False(UnitConverter.CanConvert(&quot;kg&quot;, &quot;mph&quot;));&#10;        Assert.False(UnitConverter.CanConvert(&quot;nonexistent&quot;, &quot;mph&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_ValidUnit_ReturnsConversions()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;km/h&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Contains(&quot;mph&quot;, conversions);&#10;        Assert.Contains(&quot;m/s&quot;, conversions);&#10;        Assert.Contains(&quot;knots&quot;, conversions);&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_InvalidUnit_ReturnsEmpty()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;nonexistent&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Empty(conversions);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Xunit;&#10;using System.Text.Json;&#10;&#10;namespace TemplateEngine.Tests;&#10;&#10;public class TemplateEngineTests&#10;{&#10;    [Fact]&#10;    public void ProcessTemplate_WithNumericValue_ReplacesTokenCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;The weight is {foo.value} {foo.unit}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;The weight is 2 kg&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithStringValue_ReplacesTokenCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;string_value&quot;: &quot;electric power&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;The type is {foo.value}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;The type is electric power&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithMultipleItems_ReplacesAllTokens()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;weight&quot;,&#10;          &quot;numeric_value&quot;: 2.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }, {&#10;          &quot;name&quot;:&quot;type&quot;,&#10;          &quot;string_value&quot;: &quot;electric power&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Item: {type.value}, Weight: {weight.value} {weight.unit}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Item: electric power, Weight: 2.5 kg&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNameToken_ReplacesCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;foo&quot;, NumericValue = 42, Unit = &quot;units&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        var template = &quot;Name: {foo.name}, Value: {foo.value}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Name: foo, Value: 42&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNonExistentItem_LeavesTokenUnchanged()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Value: {bar.value}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Value: {bar.value}&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithNonExistentProperty_LeavesTokenUnchanged()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;numeric_value&quot;: 2,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Value: {foo.unknown}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Value: {foo.unknown}&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithMissingUnit_ReturnsEmptyString()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;foo&quot;,&#10;          &quot;string_value&quot;: &quot;test&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Unit: '{foo.unit}'&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;Unit: ''&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void TemplateItem_Value_ReturnsStringValueWhenBothExist()&#10;    {&#10;        // Arrange&#10;        var item = new TemplateItem&#10;        {&#10;            Name = &quot;test&quot;,&#10;            StringValue = &quot;string&quot;,&#10;            NumericValue = 42&#10;        };&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;string&quot;, item.Value);&#10;    }&#10;&#10;    [Fact]&#10;    public void TemplateItem_Value_ReturnsNumericValueWhenStringIsNull()&#10;    {&#10;        // Arrange&#10;        var item = new TemplateItem&#10;        {&#10;            Name = &quot;test&quot;,&#10;            StringValue = null,&#10;            NumericValue = 42&#10;        };&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(42.0, item.Value);&#10;    }&#10;&#10;    [Fact]&#10;    public void ParseJsonData_CaseInsensitive_ParsesCorrectly()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;NAME&quot;:&quot;FOO&quot;,&#10;          &quot;NUMERIC_VALUE&quot;: 123,&#10;          &quot;UNIT&quot;: &quot;KG&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;{FOO.value} {FOO.unit}&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert&#10;        Assert.Equal(&quot;123 KG&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithRounding_RoundsCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 123.456789, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;123.46&quot;, engine.ProcessTemplate(&quot;{speed.value:round(2)}&quot;));&#10;        Assert.Equal(&quot;123&quot;, engine.ProcessTemplate(&quot;{speed.value:round(0)}&quot;));&#10;        Assert.Equal(&quot;123.4568&quot;, engine.ProcessTemplate(&quot;{speed.value:round(4)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithUnitConversion_ConvertsCorrectly()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100, Unit = &quot;km/h&quot; },&#10;            new() { Name = &quot;consumption&quot;, NumericValue = 8.5, Unit = &quot;l/100km&quot; },&#10;            new() { Name = &quot;temp&quot;, NumericValue = 25, Unit = &quot;celsius&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert - Use rounded values to avoid floating point precision issues&#10;        Assert.Equal(&quot;62.1371&quot;, engine.ProcessTemplate(&quot;{speed.value:convert(mph):round(4)}&quot;));&#10;        Assert.Equal(&quot;27.7&quot;, engine.ProcessTemplate(&quot;{consumption.value:convert(mpg):round(1)}&quot;));&#10;        Assert.Equal(&quot;77&quot;, engine.ProcessTemplate(&quot;{temp.value:convert(fahrenheit):round(0)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithConvertAndRound_AppliesInOrder()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Equal(&quot;62.1&quot;, engine.ProcessTemplate(&quot;{speed.value:convert(mph):round(1)}&quot;));&#10;        Assert.Equal(&quot;62&quot;, engine.ProcessTemplate(&quot;{speed.value:convert(mph):round(0)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithRoundAndConvert_AppliesInOrder()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;speed&quot;, NumericValue = 100.789, Unit = &quot;km/h&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act &amp; Assert&#10;        // First round to 101, then convert to mph&#10;        Assert.Equal(&quot;62.8&quot;, engine.ProcessTemplate(&quot;{speed.value:round(0):convert(mph):round(1)}&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithInvalidConversion_ReturnsOriginalValue()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;weight&quot;, NumericValue = 100, Unit = &quot;kg&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act - Try to convert kg to mph (invalid conversion)&#10;        var result = engine.ProcessTemplate(&quot;{weight.value:convert(mph)}&quot;);&#10;        &#10;        // Assert - Should return original value since conversion is not possible&#10;        Assert.Equal(&quot;100&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_WithStringValue_IgnoresModifiers()&#10;    {&#10;        // Arrange&#10;        var items = new List&lt;TemplateItem&gt;&#10;        {&#10;            new() { Name = &quot;type&quot;, StringValue = &quot;electric power&quot; }&#10;        };&#10;        &#10;        var engine = new SimpleTemplateEngine(items);&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(&quot;{type.value:round(2)}&quot;);&#10;        &#10;        // Assert - String values should ignore numeric modifiers&#10;        Assert.Equal(&quot;electric power&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void ProcessTemplate_ComplexTemplate_HandlesMultipleConversions()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;: &quot;car_speed&quot;,&#10;          &quot;numeric_value&quot;: 120.5,&#10;          &quot;unit&quot;: &quot;km/h&quot;&#10;        }, {&#10;          &quot;name&quot;: &quot;fuel_consumption&quot;,&#10;          &quot;numeric_value&quot;: 7.2,&#10;          &quot;unit&quot;: &quot;l/100km&quot;&#10;        }, {&#10;          &quot;name&quot;: &quot;temperature&quot;,&#10;          &quot;numeric_value&quot;: 22.5,&#10;          &quot;unit&quot;: &quot;celsius&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var template = &quot;Speed: {car_speed.value:convert(mph):round(1)} mph, &quot; +&#10;                      &quot;Consumption: {fuel_consumption.value:convert(mpg):round(1)} mpg, &quot; +&#10;                      &quot;Temp: {temperature.value:convert(fahrenheit):round(0)}°F&quot;;&#10;        &#10;        // Act&#10;        var result = engine.ProcessTemplate(template);&#10;        &#10;        // Assert - 22.5°C = 72.5°F, rounded to 72°F (banker's rounding)&#10;        Assert.Equal(&quot;Speed: 74.9 mph, Consumption: 32.7 mpg, Temp: 72°F&quot;, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithCustomJsonOptions_AppliesCustomConfiguration()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;myCustomName&quot;:&quot;test_item&quot;,&#10;          &quot;myCustomNumericValue&quot;: 42.5,&#10;          &quot;myCustomUnit&quot;: &quot;customUnit&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act&#10;        var engine = new SimpleTemplateEngine(jsonData, options =&gt;&#10;        {&#10;            // Override the default naming policy to use camel case&#10;            options.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;&#10;        });&#10;        &#10;        // Since we changed to camel case and the JSON properties don't match our C# properties,&#10;        // this should result in a TemplateItem with default values&#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should have one item but with default/null values since property mapping failed&#10;        Assert.Single(items);&#10;        Assert.True(string.IsNullOrEmpty(items[0].Name));&#10;        Assert.Null(items[0].NumericValue);&#10;        Assert.Null(items[0].StringValue);&#10;        Assert.Null(items[0].Unit);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithoutCustomJsonOptions_UsesDefaults()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;test_item&quot;,&#10;          &quot;numeric_value&quot;: 42.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act - No custom options provided&#10;        var engine = new SimpleTemplateEngine(jsonData);&#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should parse correctly with default options&#10;        Assert.Single(items);&#10;        Assert.Equal(&quot;test_item&quot;, items[0].Name);&#10;        Assert.Equal(42.5, items[0].NumericValue);&#10;        Assert.Equal(&quot;kg&quot;, items[0].Unit);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_WithCustomJsonOptions_PreservesDefaults()&#10;    {&#10;        // Arrange&#10;        var jsonData = &quot;&quot;&quot;&#10;        [{&#10;          &quot;name&quot;:&quot;test_item&quot;,&#10;          &quot;numeric_value&quot;: 42.5,&#10;          &quot;unit&quot;: &quot;kg&quot;&#10;        }]&#10;        &quot;&quot;&quot;;&#10;        &#10;        // Act - Custom options that don't interfere with existing functionality&#10;        var engine = new SimpleTemplateEngine(jsonData, options =&gt;&#10;        {&#10;            // Add a custom option while preserving defaults&#10;            options.AllowTrailingCommas = true;&#10;            options.ReadCommentHandling = JsonCommentHandling.Skip;&#10;        });&#10;        &#10;        var items = engine.GetItems();&#10;        &#10;        // Assert - Should still work with default case insensitive and snake_case settings&#10;        Assert.Single(items);&#10;        Assert.Equal(&quot;test_item&quot;, items[0].Name);&#10;        Assert.Equal(42.5, items[0].NumericValue);&#10;        Assert.Equal(&quot;kg&quot;, items[0].Unit);&#10;    }&#10;}&#10;&#10;public class UnitConverterTests&#10;{&#10;    [Theory]&#10;    [InlineData(&quot;km/h&quot;, &quot;mph&quot;, 100, 62.1371)]&#10;    [InlineData(&quot;km/h&quot;, &quot;m/s&quot;, 36, 10)]&#10;    [InlineData(&quot;l/100km&quot;, &quot;mpg&quot;, 8, 29.401822875)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 0, 32)]&#10;    [InlineData(&quot;celsius&quot;, &quot;fahrenheit&quot;, 100, 212)]&#10;    [InlineData(&quot;kg&quot;, &quot;lbs&quot;, 1, 2.20462)]&#10;    [InlineData(&quot;m&quot;, &quot;ft&quot;, 1, 3.28084)]&#10;    public void Convert_ValidConversions_ReturnsExpectedResult(string fromUnit, string toUnit, double input, double expected)&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(input, fromUnit, toUnit);&#10;        &#10;        // Assert&#10;        Assert.Equal(expected, result, 5); // 5 decimal places precision&#10;    }&#10;&#10;    [Fact]&#10;    public void Convert_InvalidConversion_ReturnsOriginalValue()&#10;    {&#10;        // Act&#10;        var result = UnitConverter.Convert(100, &quot;kg&quot;, &quot;mph&quot;);&#10;        &#10;        // Assert&#10;        Assert.Equal(100, result);&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_ValidConversion_ReturnsTrue()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.True(UnitConverter.CanConvert(&quot;km/h&quot;, &quot;mph&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;l/100km&quot;, &quot;mpg&quot;));&#10;        Assert.True(UnitConverter.CanConvert(&quot;celsius&quot;, &quot;fahrenheit&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void CanConvert_InvalidConversion_ReturnsFalse()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.False(UnitConverter.CanConvert(&quot;kg&quot;, &quot;mph&quot;));&#10;        Assert.False(UnitConverter.CanConvert(&quot;nonexistent&quot;, &quot;mph&quot;));&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_ValidUnit_ReturnsConversions()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;km/h&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Contains(&quot;mph&quot;, conversions);&#10;        Assert.Contains(&quot;m/s&quot;, conversions);&#10;        Assert.Contains(&quot;knots&quot;, conversions);&#10;    }&#10;&#10;    [Fact]&#10;    public void GetAvailableConversions_InvalidUnit_ReturnsEmpty()&#10;    {&#10;        // Act&#10;        var conversions = UnitConverter.GetAvailableConversions(&quot;nonexistent&quot;).ToList();&#10;        &#10;        // Assert&#10;        Assert.Empty(conversions);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/TemplateItem.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/TemplateItem.cs" />
              <option name="updatedContent" value="namespace TemplateEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents a template item with a name, value (either string or numeric), and optional unit.&#10;/// &lt;/summary&gt;&#10;public class TemplateItem&#10;{&#10;    /// &lt;summary&gt;&#10;    /// The name of the template item.&#10;    /// &lt;/summary&gt;&#10;    public string Name { get; set; } = string.Empty;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// The numeric value of the item, if applicable.&#10;    /// &lt;/summary&gt;&#10;    public double? NumericValue { get; set; }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// The string value of the item, if applicable.&#10;    /// &lt;/summary&gt;&#10;    public string? StringValue { get; set; }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// The unit of measurement for the value, if applicable.&#10;    /// &lt;/summary&gt;&#10;    public string? Unit { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the value, prioritizing string value over numeric value.&#10;    /// &lt;/summary&gt;&#10;    public object? Value =&gt; StringValue ?? (object?)NumericValue;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TemplateEngine/UnitConverter.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TemplateEngine/UnitConverter.cs" />
              <option name="updatedContent" value="namespace TemplateEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// Provides unit conversion functionality for various measurement types.&#10;/// &lt;/summary&gt;&#10;public static class UnitConverter&#10;{&#10;    private static readonly Dictionary&lt;string, Dictionary&lt;string, Func&lt;double, double&gt;&gt;&gt; _conversions = new()&#10;    {&#10;        [&quot;km/h&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;mph&quot;] = value =&gt; value * 0.621371,&#10;            [&quot;m/s&quot;] = value =&gt; value / 3.6,&#10;            [&quot;knots&quot;] = value =&gt; value * 0.539957&#10;        },&#10;        [&quot;l/100km&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;mpg&quot;] = value =&gt; 235.214583 / value, // US gallons&#10;            [&quot;mpg_uk&quot;] = value =&gt; 282.481 / value, // UK gallons&#10;            [&quot;km/l&quot;] = value =&gt; 100 / value&#10;        },&#10;        [&quot;celsius&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;fahrenheit&quot;] = value =&gt; (value * 9 / 5) + 32,&#10;            [&quot;kelvin&quot;] = value =&gt; value + 273.15&#10;        },&#10;        [&quot;kg&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;lbs&quot;] = value =&gt; value * 2.20462,&#10;            [&quot;oz&quot;] = value =&gt; value * 35.274&#10;        },&#10;        [&quot;m&quot;] = new Dictionary&lt;string, Func&lt;double, double&gt;&gt;&#10;        {&#10;            [&quot;ft&quot;] = value =&gt; value * 3.28084,&#10;            [&quot;inches&quot;] = value =&gt; value * 39.3701,&#10;            [&quot;miles&quot;] = value =&gt; value * 0.000621371,&#10;            [&quot;km&quot;] = value =&gt; value / 1000&#10;        }&#10;    };&#10;&#10;    /// &lt;summary&gt;&#10;    /// Converts a value from one unit to another.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to convert.&lt;/param&gt;&#10;    /// &lt;param name=&quot;fromUnit&quot;&gt;The source unit.&lt;/param&gt;&#10;    /// &lt;param name=&quot;toUnit&quot;&gt;The target unit.&lt;/param&gt;&#10;    /// &lt;returns&gt;The converted value, or the original value if conversion is not supported.&lt;/returns&gt;&#10;    public static double Convert(double value, string fromUnit, string toUnit)&#10;    {&#10;        if (_conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions))&#10;        {&#10;            if (conversions.TryGetValue(toUnit.ToLowerInvariant(), out var converter))&#10;            {&#10;                return converter(value);&#10;            }&#10;        }&#10;        &#10;        // If no conversion found, return original value&#10;        return value;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Checks if a conversion from one unit to another is supported.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;fromUnit&quot;&gt;The source unit.&lt;/param&gt;&#10;    /// &lt;param name=&quot;toUnit&quot;&gt;The target unit.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the conversion is supported, false otherwise.&lt;/returns&gt;&#10;    public static bool CanConvert(string fromUnit, string toUnit)&#10;    {&#10;        return _conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions) &amp;&amp;&#10;               conversions.ContainsKey(toUnit.ToLowerInvariant());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets all available conversion targets for a given source unit.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;fromUnit&quot;&gt;The source unit.&lt;/param&gt;&#10;    /// &lt;returns&gt;An enumerable of available target units.&lt;/returns&gt;&#10;    public static IEnumerable&lt;string&gt; GetAvailableConversions(string fromUnit)&#10;    {&#10;        if (_conversions.TryGetValue(fromUnit.ToLowerInvariant(), out var conversions))&#10;        {&#10;            return conversions.Keys;&#10;        }&#10;        return Enumerable.Empty&lt;string&gt;();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>